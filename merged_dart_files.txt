
// ===== FILE: ./lib/core/config/app_initializer.dart =====



// ===== FILE: ./lib/core/config/environment.dart =====



// ===== FILE: ./lib/core/network/api_endpoints.dart =====



// ===== FILE: ./lib/core/network/api_client.dart =====



// ===== FILE: ./lib/core/network/websocket_client.dart =====



// ===== FILE: ./lib/core/utils/logger.dart =====



// ===== FILE: ./lib/core/utils/formatters.dart =====

String generateTimestampedFileName(String originalFileName) {
  final timestamp = DateTime.now().millisecondsSinceEpoch; // 현재 타임스탬프 (밀리초)
  final extensionIndex = originalFileName.lastIndexOf('.'); // 확장자 위치 찾기

  if (extensionIndex != -1) {
    final name = originalFileName.substring(0, extensionIndex); // 파일명 부분
    final extension = originalFileName.substring(extensionIndex); // 확장자 부분
    return '${name}_$timestamp$extension'; // 예: "document_1706789123456.pdf"
  } else {
    return '${originalFileName}_$timestamp'; // 확장자가 없는 경우
  }
}

// ===== FILE: ./lib/core/utils/validators.dart =====



// ===== FILE: ./lib/core/setting/setting_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/app/app_theme.dart';
import 'package:legalfactfinder2025/features/authentication/auth_controller.dart';
import 'package:legalfactfinder2025/features/files/presentation/test_syncfusion_pdf_file_view_page.dart';

class SettingScreen extends StatelessWidget {
  final AuthController authController = Get.find();

  SettingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(20.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const SizedBox(height: 20),
          Text("Account Settings", style: Theme.of(context).textTheme.titleLarge),
          const SizedBox(height: 10),

          // ✅ 사용자 정보 표시
          Obx(() {
            final user = authController.currentUser.value;
            if (user == null) {
              return const Text("Not logged in", style: AppTheme.defaultTextStyle);
            }

            return Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text("Email: ${user.email ?? 'Unknown'}", style: AppTheme.defaultTextStyle),
                Text("User ID: ${user.id}", style: AppTheme.defaultTextStyle),
                const SizedBox(height: 20),
              ],
            );
          }),

          // ✅ 로그아웃 버튼 (Outline 스타일)
          OutlinedButton(
            onPressed: () {
              _showLogoutDialog(context);
            },
            style: OutlinedButton.styleFrom(
              foregroundColor: Colors.blue,
              side: const BorderSide(color: Colors.blue, width: 1.5),
              padding: const EdgeInsets.symmetric(vertical: 14),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
            ),
            child: const Center(child: Text("Log Out")),
          ),
          const SizedBox(height: 10),

          // ✅ 회원 탈퇴 버튼 (빨간색 Outline 스타일)
          OutlinedButton(
            onPressed: () {
              _showWithdrawMembershipDialog(context);
            },
            style: OutlinedButton.styleFrom(
              foregroundColor: Colors.red,
              side: const BorderSide(color: Colors.red, width: 1.5),
              padding: const EdgeInsets.symmetric(vertical: 14),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
            ),
            child: const Center(child: Text("Withdraw Membership")),
          ),

          const SizedBox(height: 10),

          OutlinedButton(
            onPressed: () {
              Get.to(() => TestSyncfusionPdfFileViewPage());
            },
            style: OutlinedButton.styleFrom(
              foregroundColor: Colors.green,
              side: BorderSide(color: Colors.green, width: 1.5),
              padding: EdgeInsets.symmetric(vertical: 14),
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
            ),
            child: Center(child: Text("Open PDF Viewer")),
          )
        ],
      ),
    );
  }

  // ✅ 로그아웃 확인 다이얼로그
  void _showLogoutDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text("Log Out"),
          content: const Text("Are you sure you want to log out?"),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("Cancel", style: AppTheme.interactiveTextStyle),
            ),
            TextButton(
              onPressed: () {
                Navigator.pop(context);
                authController.signOut();
              },
              child: const Text("Log Out", style: TextStyle(color: Colors.red)),
            ),
          ],
        );
      },
    );
  }

  // ✅ 회원 탈퇴 확인 다이얼로그
  void _showWithdrawMembershipDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text("Withdraw Membership"),
          content: const Text(
              "Are you sure you want to withdraw your membership? "
                  "This will permanently delete your account and all associated data. "
                  "This action cannot be undone."),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("Cancel", style: AppTheme.interactiveTextStyle),
            ),
            TextButton(
              onPressed: () async {
                Navigator.pop(context);
                await authController.deleteAccount();
              },
              child: const Text("Withdraw", style: TextStyle(color: Colors.red)),
            ),
          ],
        );
      },
    );
  }
}


// ===== FILE: ./lib/core/widgets/custom_button.dart =====



// ===== FILE: ./lib/core/widgets/app_loader.dart =====



// ===== FILE: ./lib/core/widgets/custom_text_field.dart =====



// ===== FILE: ./lib/app/main_layout.dart =====

import 'dart:io';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/audio_record/presentation/audio_recorder_page.dart';
import 'package:legalfactfinder2025/features/authentication/auth_controller.dart';
import 'package:legalfactfinder2025/features/friend/presentation/friend_request_page.dart';
import 'package:legalfactfinder2025/features/notification/presentation/notification_screen.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/work_room_list_screen.dart';
import 'package:legalfactfinder2025/features/friend/presentation/friend_list_screen.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/add_work_room_page.dart';
import 'package:legalfactfinder2025/core/setting/setting_screen.dart';

class MainLayout extends StatefulWidget {
  const MainLayout({super.key});

  @override
  _MainLayoutState createState() => _MainLayoutState();
}

class _MainLayoutState extends State<MainLayout> {
  late AuthController authController;

  @override
  void initState() {
    super.initState();

    // Initialize the AuthController
    authController = Get.find<AuthController>();

    // Fetch userId and check authentication status
    print("Checking authentication status...");
    authController.refreshUser(); // Refresh user info
  }

  @override
  Widget build(BuildContext context) {
    final bottomPadding = MediaQuery.of(context).viewPadding.bottom;
    final isRoundedDevice = Platform.isIOS && bottomPadding > 20;
    return Scaffold(
      body: Obx(() {
        // Check if userId is null, and show loading until it's fetched
        if (authController.userId.value == null) {
          print("User is not logged in yet. Displaying loading screen...");
          return const Center(child: CircularProgressIndicator());
        }

        print("MainLayout: User is logged in!");

        final List<Widget> screens = [
          WorkRoomListScreen(myUserId: authController.userId.value!), // Pass the logged-in user ID
          FriendListScreen(),
          const Center(child: Text('Call History Page')),
          SettingScreen(),
        ];

        return DefaultTabController(
          length: screens.length,
          child: Scaffold(
            appBar: AppBar(
              backgroundColor: Colors.white,
              automaticallyImplyLeading: false,
              title: Row(
                children: [
                  Expanded(
                    child: GestureDetector(
                      onTap: () {
                        print("Search tapped");
                      },
                      child: Container(
                        height: 36,
                        decoration: BoxDecoration(
                          color: Colors.black.withOpacity(0.1),
                          borderRadius: BorderRadius.circular(25),
                        ),
                        padding: const EdgeInsets.symmetric(horizontal: 12),
                        alignment: Alignment.centerLeft,
                        child: Row(
                          children: const [
                            Icon(Icons.search),
                            SizedBox(width: 8),
                            Text('Search...', style: TextStyle(fontSize: 14)),
                          ],
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(width: 16),
                  GestureDetector(
                    onTap: () => _showBottomSheet(context),
                    child: const Padding(
                      padding: EdgeInsets.all(8.0),
                      child: Icon(Icons.add_box),
                    ),
                  ),
                  GestureDetector(
                    onTap: () {
                      print("Navigating to Notifications page...");
                      Get.to(() => NotificationPage());
                    },
                    child: const Padding(
                      padding: EdgeInsets.all(8.0),
                      child: Icon(Icons.notifications),
                    ),
                  ),
                ],
              ),
            ),
            body: TabBarView(

              physics: const NeverScrollableScrollPhysics(),
              children: screens,
            ),
            bottomNavigationBar: Padding(
              padding: EdgeInsets.only(bottom: isRoundedDevice  ? 10 : 0),
              child: const TabBar(
                tabs: [
                  Tab(icon: Icon(Icons.meeting_room)),
                  Tab(icon: Icon(Icons.group)),
                  Tab(icon: Icon(Icons.history)),
                  Tab(icon: Icon(Icons.settings)),
                ],
                labelColor: Colors.lightBlue,
                unselectedLabelColor: Colors.grey,
                indicatorColor: Colors.transparent,
              ),
            ),
          ),
        );
      }),
    );
  }

  // Function to show the bottom sheet for various actions
  void _showBottomSheet(BuildContext context) {
    print("Opening bottom sheet...");
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      builder: (context) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.person_add),
              title: const Text('친구 초대'),
              onTap: () {
                Navigator.pop(context);
                print("친구 초대 선택");
                Get.to(() => FriendRequestPage());

              },
            ),
            ListTile(
              leading: const Icon(Icons.note_add),
              title: const Text('회의록 생성'),
              onTap: () {
                Navigator.pop(context);
                print("Navigating to Audio Recorder page...");
                Get.to(() => AudioRecorderPage());
              },
            ),
            ListTile(
              leading: const Icon(Icons.meeting_room),
              title: const Text('Work Room 생성'),
              onTap: () {
                Navigator.pop(context);
                print("Navigating to Add Work Room page...");
                Get.to(() => const AddWorkRoomPage());
              },
            ),
          ],
        );
      },
    );
  }
}


// ===== FILE: ./lib/app/app_routes.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/app/main_layout.dart';
import 'package:legalfactfinder2025/features/authentication/presentation/login_page.dart';
import 'package:legalfactfinder2025/features/authentication/presentation/register_page.dart';
import 'package:legalfactfinder2025/features/authentication/presentation/reset_password_page.dart';
import 'package:legalfactfinder2025/features/authentication/presentation/verify_email_page.dart';
import 'package:legalfactfinder2025/features/notification/presentation/notification_screen.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/work_room_page.dart';
import 'package:legalfactfinder2025/features/chat/presentation/chat_screen.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/invitation_page.dart';
import 'package:legalfactfinder2025/features/friend/presentation/friend_list_screen.dart';
import 'package:legalfactfinder2025/features/friend/presentation/friend_request_page.dart';

class AppRoutes {
  static const String login = '/login';
  static const String register = '/register';

  static const String resetPW = '/reset-password';
  static const String verifyEmail = '/verify-email';


   static const String main = '/main';

  static const String workRoom = '/work_room/:workRoomId';
  static const String invitation = '/invitation';
  static const String friendRequest = '/friend_request';

  static const String userNotifications = '/user_notifications';

  static final List<GetPage> routes = [
    GetPage(name: login, page: () =>   LoginPage()),
    GetPage(name: register, page: () =>   RegisterPage()),
    GetPage(name: verifyEmail, page: () =>   VerifyEmailPage()),

    GetPage(name: resetPW, page: () =>   ResetPasswordPage()),
     GetPage(name: main, page: () =>   MainLayout()),
    GetPage(name: workRoom, page: () =>   WorkRoomPage()),
    GetPage(name: invitation, page: () => const InvitationPage()),
    GetPage(name: friendRequest, page: () =>   FriendRequestPage()),
    GetPage(name:userNotifications, page: () => NotificationPage()),
    GetPage(name: '/reset-password', page: () => ResetPasswordPage()),
  ];
}


// ===== FILE: ./lib/app/app_theme.dart =====

import 'package:flutter/material.dart';

class AppTheme {
  // Colors
  static const Color primaryColor = Colors.white; // 기본 색상
  static const Color scaffoldBackgroundColor = Colors.white;
  static const Color dividerColor = Color(0xFFDDDDDD);
  static const Color titleTextColor = Colors.black;
  static const Color descriptionTextColor = Colors.grey;
  static const Color chipBackgroundColor = Colors.white;
  static const Color chipTextColor = Colors.black;
  static const Color listEndBackgroundColor = Color(0xFF424242);
  static const Color listEndTextColor = Colors.white;
  static const Color appBarBottomBorderColor = Color(0xFFDDDDDD);
  static const Color interactiveTextColor = Colors.blueAccent; // 클릭 가능한 텍스트 색상

  // Chip Theme
  static ChipThemeData chipTheme = ChipThemeData(
    backgroundColor: chipBackgroundColor,
    labelStyle: const TextStyle(fontSize: 12, color: chipTextColor),
    secondaryLabelStyle: const TextStyle(fontSize: 12, color: chipTextColor),
  );

  // AppBar Theme
  static AppBarTheme appBarTheme = const AppBarTheme(
    elevation: 1,
    toolbarHeight: 48.0,
    backgroundColor: Colors.white,
    titleTextStyle: TextStyle(
      fontWeight: FontWeight.bold,
      fontSize: 16,
      color: Colors.black,
    ),
    iconTheme: IconThemeData(size: 20),
  );
  // ✅ Progress Indicator Theme (로딩 인디케이터 색상 설정)
  static ProgressIndicatorThemeData progressIndicatorTheme = ProgressIndicatorThemeData(
    color: primaryColor, // ✅ CircularProgressIndicator 색상 변경
  );
// Text Field Theme
  static InputDecorationTheme inputDecorationTheme = InputDecorationTheme(
    filled: true,
    fillColor: Colors.grey[200], // 입력 필드 배경색
    border: OutlineInputBorder(
      borderRadius: BorderRadius.circular(8),
      borderSide: const BorderSide(color: Colors.grey),
    ),
    focusedBorder: OutlineInputBorder(
      borderRadius: BorderRadius.circular(8),
      borderSide: const BorderSide(color: Colors.blue, width: 2), // ✅ 포커스 시 테두리 색상 파란색
    ),
    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),

    // ✅ 클릭 전 (라벨이 큰 글씨로 입력 필드 내부에 있을 때)
    labelStyle: const TextStyle(
      color: Colors.grey, // 진회색
      fontSize: 16, // 기본 크기
    ),

    // ✅ 클릭 후 (포커스 시 라벨이 작아지면서 위로 올라갈 때)
    floatingLabelStyle: const TextStyle(
      color: Colors.blue, // 파란색
      fontSize: 12, // 작아짐
    ),
  );
  // Checkbox Theme (Setting the color of the checkbox)
  static CheckboxThemeData checkboxTheme = CheckboxThemeData(
    checkColor: MaterialStateProperty.all(Colors.white), // Checkmark color (white)
    fillColor: MaterialStateProperty.resolveWith<Color>(
          (Set<MaterialState> states) {
        if (states.contains(MaterialState.selected)) {
          // When selected (checked), set background to blue
          return Colors.blue;
        }
        // When not selected (unchecked), set background to white
        return Colors.white;
      },
    ),
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(4),
    ),
  );
  // Button Theme
  static ElevatedButtonThemeData elevatedButtonTheme = ElevatedButtonThemeData(
    style: ElevatedButton.styleFrom(
      backgroundColor: Colors.blue,
      foregroundColor: Colors.white,
      padding: const EdgeInsets.symmetric(vertical: 14),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(6),
      ),
    ),
  );

  // Text Styles
  static const TextStyle defaultTextStyle = TextStyle(color: Colors.black);
  static const TextStyle interactiveTextStyle = TextStyle(
    color: interactiveTextColor,
    fontWeight: FontWeight.w500,
  );

  // 전체 ThemeData
  static ThemeData themeData = ThemeData(
    primarySwatch: Colors.blue, // 앱 기본 색상 (파란색 계열)
    floatingActionButtonTheme: FloatingActionButtonThemeData(
      backgroundColor: Colors.blue, // FAB 색상을 파란색으로 설정
      foregroundColor: Colors.white, // 아이콘 색상을 흰색으로 설정
    ),    progressIndicatorTheme: progressIndicatorTheme, // ✅ 적용

    scaffoldBackgroundColor: scaffoldBackgroundColor,
    dividerColor: dividerColor,
    chipTheme: chipTheme,
    appBarTheme: appBarTheme,
    inputDecorationTheme: inputDecorationTheme,
    elevatedButtonTheme: elevatedButtonTheme,
    splashFactory: NoSplash.splashFactory,
    highlightColor: Colors.transparent,
    splashColor: Colors.transparent,    checkboxTheme: checkboxTheme, // Apply the Checkbox Theme here

  );
}


// ===== FILE: ./lib/app/constants.dart =====



// ===== FILE: ./lib/features/confidentiality/signature_status_controller.dart =====

import 'package:get/get.dart';
 import 'package:legalfactfinder2025/features/confidentiality/data/signature_status_model.dart';
import 'package:legalfactfinder2025/features/confidentiality/data/signature_status_repository.dart';

class SignatureStatusController extends GetxController {
  final SignatureStatusRepository repository = SignatureStatusRepository();

  // 작업방 서명 상태를 저장하는 리스트
  var signatures = <SignatureStatusModel>[].obs;

  /// 작업방의 서명 상태를 로드하는 함수
  Future<void> loadSignatures(String workRoomId) async {
    try {
      final fetchedSignatures = await repository.fetchSignatureStatusForWorkRoom(workRoomId);
      signatures.value = fetchedSignatures;
      print('✅ Signatures loaded successfully for workRoomId: $workRoomId');
    } catch (e) {
      print('❌ Error loading signatures: $e');
    }
  }

  /// 서버에서 서명 상태를 다시 가져오는 함수
  Future<void> refreshSignatures(String workRoomId) async {
    print('🔄 Refreshing signatures...');
    await loadSignatures(workRoomId);
  }
}


// ===== FILE: ./lib/features/confidentiality/signature_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/confidentiality/data/signature_status_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class MySignatureController extends GetxController {
  final SupabaseClient _supabase = Supabase.instance.client;
  // 작업방의 서명 상태 목록을 저장할 상태 변수
  var signatureStatusList = <SignatureStatusModel>[].obs;
  /// **서명 정보를 Supabase DB에 저장하는 함수**
  Future<void> saveSignatureToDatabase(String userId, String workRoomId, String storagePath) async {
    try {
      final response = await _supabase.functions.invoke(
        'put_signature', // ✅ Supabase Edge Function 호출
        body: {
          "p_user_id": userId,
          "p_work_room_id": workRoomId,
          "p_image_file_storage_key": storagePath,
        },
      );

      // 응답 결과 확인
      if (response.data == null || (response.data is Map && response.data.containsKey('error'))) {
        throw Exception('Failed to save signature: ${response.data?['error'] ?? 'Unknown error'}');
      }

      print('✅ Signature stored in database successfully.');
    } catch (e) {
      print('❌ Error saving signature in database: $e');
    }
  }
  /// **작업방의 서명 상태를 로드하는 함수**
  Future<void> fetchSignaturesForWorkRoom(String workRoomId) async {
    try {
      final response = await _supabase.functions.invoke(
        'get_signatures_for_work_room', // ✅ Supabase Edge Function 호출
        body: {
          "p_work_room_id": workRoomId,
        },
      );

      if (response.data == null) {
        throw Exception('Failed to fetch signatures: Response is null');
      }

      // 응답 데이터를 모델 리스트로 변환하여 상태 업데이트
      final List<dynamic> data = response.data as List<dynamic>;
      signatureStatusList.value =
          data.map((item) => SignatureStatusModel.fromJson(item)).toList();

      print('✅ Signatures fetched successfully.');
    } catch (e) {
      print('❌ Error fetching signatures for work room: $e');
    }
  }
}


// ===== FILE: ./lib/features/confidentiality/data/signature_status_repository.dart =====

import 'dart:typed_data';
import 'package:legalfactfinder2025/features/confidentiality/data/signature_status_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class SignatureStatusRepository {
  final SupabaseClient _supabase = Supabase.instance.client;

  /// 서명 업로드 메서드
  Future<String?> uploadSignature(String userId, String workRoomId, Uint8List data) async {
    try {
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = '$userId$timestamp.png';
      final storagePath = '$workRoomId/$fileName';

      print('🔹 Uploading signature...');
      print('  User ID: $userId');
      print('  Work Room ID: $workRoomId');
      print('  File Name: $fileName');
      print('  Storage Path: $storagePath');

      final String? uploadedFilePath = await _supabase.storage
          .from('work_room_signatures')
          .uploadBinary(storagePath, data, fileOptions: const FileOptions(contentType: 'image/png'));

      if (uploadedFilePath == null) {
        print('❌ Upload failed');
        throw Exception('Upload failed');
      }

      print('✅ Signature uploaded to: $uploadedFilePath');
      return storagePath;
    } catch (e) {
      print('❌ Upload error: $e');
      return null;
    }
  }

  /// 서명 정보를 Supabase DB에 저장하는 메서드
  Future<void> saveSignatureToDatabase(String userId, String workRoomId, String storagePath) async {
    try {
      print('🔹 Saving signature to database...');
      print('  User ID: $userId');
      print('  Work Room ID: $workRoomId');
      print('  Storage Path: $storagePath');

      final response = await _supabase.functions.invoke(
        'put_signature',
        body: {
          "user_id": userId,
          "work_room_id": workRoomId,
          "image_file_storage_key": storagePath,
        },
      );

      if (response.data == null || (response.data is Map && response.data.containsKey('error'))) {
        print('❌ Failed to save signature: ${response.data?['error'] ?? 'Unknown error'}');
        throw Exception('Failed to save signature');
      }

      print('✅ Signature stored in database successfully.');
    } catch (e) {
      print('❌ DB error: $e');
    }
  }

  /// 작업방의 모든 참가자와 서명 정보를 가져오는 메서드
  Future<List<SignatureStatusModel>> fetchSignatureStatusForWorkRoom(String workRoomId) async {
    try {
      print('🔹 Fetching signature status for work room...');
      print('  Work Room ID: $workRoomId');

      final response = await _supabase.functions.invoke(
        'get_signatures_for_work_room',
        body: {
          "p_work_room_id": workRoomId,
        },
      );

      if (response.data == null) {
        print('❌ Response is null');
        throw Exception('Failed to fetch signatures: Response is null');
      }

      // Raw 데이터 로깅
      print('🟢 Raw Response Data: ${response.data}');

      // response.data['data']에 접근하여 리스트로 변환
      final Map<String, dynamic> responseData = response.data as Map<String, dynamic>;
      final List<dynamic> data = responseData['data'] as List<dynamic>;

      print('🔹 Parsing response data...');
      final signatures = data.map((item) {
        print('  Parsing item: $item');
        return SignatureStatusModel.fromJson(item as Map<String, dynamic>);
      }).toList();

      print('✅ Successfully fetched and parsed signatures.');
      return signatures;
    } catch (e) {
      print('❌ Error fetching signatures for work room: $e');
      return [];
    }
  }
}


// ===== FILE: ./lib/features/confidentiality/data/signature_status_model.dart =====

class SignatureStatusModel {
  final String userId;
  final String workRoomId;
  final String username;
  final String? profilePictureUrl;
  final bool isLawyer;
  final DateTime? signedAt;
  final String? imageFileStorageKey;

  SignatureStatusModel({
    required this.userId,
    required this.workRoomId,
    required this.username,
    this.profilePictureUrl,
    required this.isLawyer,
    this.signedAt,
    this.imageFileStorageKey,
  });

  /// JSON 데이터를 SignatureStatusModel 객체로 변환
  factory SignatureStatusModel.fromJson(Map<String, dynamic> json) {
    return SignatureStatusModel(
      userId: json['user_id'] as String,
      workRoomId: json['work_room_id'] as String,
      username: json['username'] as String,
      profilePictureUrl: json['profile_picture_url'] as String?,
      isLawyer: json['is_lawyer'] as bool,
      signedAt: json['signed_at'] != null ? DateTime.parse(json['signed_at']) : null,
      imageFileStorageKey: json['image_file_storage_key'] as String?,
    );
  }

  /// 객체를 JSON으로 변환
  Map<String, dynamic> toJson() {
    return {
      'user_id': userId,
      'work_room_id': workRoomId,
      'username': username,
      'profile_picture_url': profilePictureUrl,
      'is_lawyer': isLawyer,
      'signed_at': signedAt?.toIso8601String(),
      'image_file_storage_key': imageFileStorageKey,
    };
  }
}


// ===== FILE: ./lib/features/confidentiality/data/signature_model.dart =====

class SignatureModel {
  final String id; // 고유 ID (UUID)
  final String userId; // 사용자 ID (users 테이블 참조)
  final String workRoomId; // 작업 방 ID (work_rooms 테이블 참조)
  final DateTime? signedAt; // 서명 날짜 및 시간
  final String imageFileStorageKey; // 서명 이미지 파일 스토리지 키

  SignatureModel({
    required this.id,
    required this.userId,
    required this.workRoomId,
    this.signedAt,
    required this.imageFileStorageKey,
  });

  // JSON 데이터를 객체로 변환하는 메서드
  factory SignatureModel.fromJson(Map<String, dynamic> json) {
    return SignatureModel(
      id: json['id'],
      userId: json['user_id'],
      workRoomId: json['work_room_id'],
      signedAt: json['signed_at'] != null
          ? DateTime.parse(json['signed_at'])
          : null,
      imageFileStorageKey: json['image_file_storage_key'] ?? '',
    );
  }

  // 객체를 JSON으로 변환하는 메서드
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'user_id': userId,
      'work_room_id': workRoomId,
      'signed_at': signedAt?.toIso8601String(),
      'image_file_storage_key': imageFileStorageKey,
    };
  }
}


// ===== FILE: ./lib/features/confidentiality/domain/sign_agreement_usecase.dart =====



// ===== FILE: ./lib/features/confidentiality/domain/fetch_agreement_status_usecase.dart =====



// ===== FILE: ./lib/features/confidentiality/presentation/confidentiality_screen.dart =====



// ===== FILE: ./lib/features/confidentiality/presentation/signature_status_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:legalfactfinder2025/features/confidentiality/presentation/signature_page.dart';
import 'package:legalfactfinder2025/features/confidentiality/signature_status_controller.dart';

class SignatureStatusScreen extends StatelessWidget {
  final String workRoomId; // 작업 방 ID

  final SignatureStatusController controller =
  Get.put(SignatureStatusController());

  final SupabaseClient supabaseClient = Supabase.instance.client; // Supabase 클라이언트

  SignatureStatusScreen({Key? key, required this.workRoomId}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // 작업방의 서명 정보를 불러옵니다.
    controller.loadSignatures(workRoomId);

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 서약 내용
          Text(
            'Confidentiality Agreement',
            style: Theme.of(context).textTheme.titleMedium,
          ),
          const SizedBox(height: 8),
          const Text(
            'This work room contains sensitive information. All participating lawyers must sign the confidentiality agreement to ensure that the information, files, and discussions remain secure.',
          ),
          const SizedBox(height: 16),

          // 서명 상태 표시
          Expanded(
            child: Obx(() {
              if (controller.signatures.isEmpty) {
                return const Center(
                  child: Text('No signatures available'),
                );
              }
              return ListView.builder(
                itemCount: controller.signatures.length,
                itemBuilder: (context, index) {
                  final signature = controller.signatures[index];
                  final imageUrl = signature.imageFileStorageKey != null
                      ? supabaseClient.storage
                      .from('work_room_signatures')
                      .getPublicUrl(signature.imageFileStorageKey!)
                       : null;

                  return ListTile(
                    leading: CircleAvatar(
                      backgroundImage: NetworkImage(signature.profilePictureUrl ?? ''),
                      onBackgroundImageError: (_, __) => const Icon(Icons.person),
                    ),
                    title: Text(signature.username),
                    subtitle: Text(
                      signature.signedAt != null
                          ? 'Signed on ${signature.signedAt?.toLocal()}'
                          : 'Not signed yet',
                      style: TextStyle(
                        color: signature.signedAt != null ? Colors.green : Colors.red,
                      ),
                    ),
                    trailing: signature.signedAt != null
                        ? GestureDetector(
                      onTap: () {
                        _showSignatureImage(context, imageUrl);
                      },
                      child: Stack(
                        alignment: Alignment.center,
                        children: [
                          // 서명 이미지 (반투명 처리)
                          imageUrl != null
                              ? Image.network(
                            imageUrl,
                            width: 50,
                            height: 50,
                            fit: BoxFit.scaleDown,
                            color: Colors.white.withOpacity(0.3),
                            colorBlendMode: BlendMode.darken,
                            errorBuilder: (_, __, ___) => const Icon(Icons.broken_image),
                          )
                              : const Icon(Icons.broken_image),
                          // "SIGN" 텍스트
                          const Text(
                            'SIGN',
                            style: TextStyle(
                              color: Colors.grey,
                              fontSize: 12,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ],
                      ),
                    )
                        : ElevatedButton(
                      onPressed: () {
                        _navigateToSignaturePage(context, signature.userId);
                      },
                      child: const Text('SIGN'),
                    ),
                  );
                },
              );
            }),
          ),
        ],
      ),
    );
  }

  void _showSignatureImage(BuildContext context, String? imageUrl) {
    if (imageUrl == null) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('No signature image available')),
      );
      return;
    }

    Navigator.of(context).push(
      MaterialPageRoute(
        builder: (context) => Scaffold(
          appBar: AppBar(
            title: const Text('Signature Image'),
          ),
          body: Center(
            child: Image.network(
              imageUrl,
              fit: BoxFit.contain,
              errorBuilder: (_, __, ___) => const Icon(Icons.broken_image),
            ),
          ),
        ),
      ),
    );
  }

  void _navigateToSignaturePage(BuildContext context, String userId) {
    Get.to(() => SignaturePage(userId: userId, workRoomId: workRoomId))!.then((result) {
      if (result == true) {
        // 서명을 완료한 경우 상태를 업데이트
        controller.refreshSignatures(workRoomId);
      }
    });
  }
}


// ===== FILE: ./lib/features/confidentiality/presentation/signature_page.dart =====

import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/confidentiality/signature_controller.dart';
import 'package:signature/signature.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class SignaturePage extends StatelessWidget {
  final String userId; // 사용자 ID
  final String workRoomId;

  // Signature 캔버스를 위한 컨트롤러
  final SignatureController _signatureCanvasController = SignatureController(
    penStrokeWidth: 5,
    penColor: Colors.black,
    exportBackgroundColor: Colors.white,
  );

  // GetX 상태 관리용 컨트롤러 (수정됨)
  final MySignatureController mySignatureController = Get.put(MySignatureController());

  SignaturePage({Key? key, required this.userId, required this.workRoomId}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Sign Confidentiality Agreement'),
      ),
      body: Column(
        children: [
          // 비밀유지서약 내용
          Expanded(
            flex: 2, // 전체 화면의 2/5 비율로 설정
            child: Container(
              color: Colors.grey[300], // 배경을 회색으로 설정
              padding: const EdgeInsets.all(16.0),
              child: Container(
                decoration: BoxDecoration(
                  color: Colors.white, // 내부 흰색 배경
                  border: Border.all(color: Colors.grey, width: 1), // 얇은 회색 테두리
                  borderRadius: BorderRadius.circular(4), // 라운드 코너 줄임
                ),
                padding: const EdgeInsets.all(16.0),
                child: Scrollbar(
                  thumbVisibility: true, // 스크롤바 항상 표시
                  radius: const Radius.circular(4), // 스크롤바 모서리 줄임
                  thickness: 3, // 스크롤바 두께
                  child: SingleChildScrollView(
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          'Confidentiality Agreement',
                          style: Theme.of(context).textTheme.titleLarge,
                        ),
                        const SizedBox(height: 16),
                        const Text(
                          'This confidentiality agreement ensures that all sensitive information, files, and discussions within this workspace remain secure and private. '
                              'By signing this agreement, you agree to maintain strict confidentiality and not disclose any information to unauthorized parties. '
                              'Failure to comply may result in legal consequences. Please read this agreement thoroughly before proceeding to sign below.',
                          style: TextStyle(fontSize: 16),
                        ),
                        const SizedBox(height: 16),
                        const Text(
                          'By signing, you also acknowledge that any breach of confidentiality may lead to disciplinary actions or termination of access to the workspace.',
                          style: TextStyle(fontSize: 16),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
            ),
          ),

          // 서명 공간
          Expanded(
            flex: 3, // 전체 화면의 3/5 비율로 설정
            child: Container(
              color: Colors.grey[300], // 배경을 회색으로 설정
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  // 서명란
                  Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Container(
                      padding: const EdgeInsets.all(8.0),
                      decoration: BoxDecoration(
                        color: Colors.white, // 서명란 배경 하얀색
                        border: Border.all(color: Colors.black, width: 1.0), // 테두리 강조
                        borderRadius: BorderRadius.circular(4), // 라운드 코너 줄임
                      ),
                      child: AspectRatio(
                        aspectRatio: 4 / 3, // 4:3 비율 설정
                        child: Stack(
                          children: [
                            // 배경 텍스트
                            Center(
                              child: Text(
                                'Draw Signature',
                                style: TextStyle(
                                  color: Colors.grey[400], // 연한 회색 텍스트
                                  fontSize: 24,
                                  fontWeight: FontWeight.bold,
                                ),
                              ),
                            ),
                            // 서명 캔버스
                            Signature(
                              controller: _signatureCanvasController,
                              backgroundColor: Colors.transparent, // 투명 배경
                            ),
                          ],
                        ),
                      ),
                    ),
                  ),

                  // 버튼
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                    children: [
                      ElevatedButton(
                        onPressed: () => _signatureCanvasController.clear(),
                        child: const Text('Clear'),
                      ),
                      ElevatedButton(
                        onPressed: () async {
                          if (_signatureCanvasController.isNotEmpty) {
                            final Uint8List? data = await _signatureCanvasController.toPngBytes();
                            if (data != null) {
                              await _saveSignature(data);
                              Get.back(result: true); // 서명 완료 후 true 반환
                            }
                          }
                        },
                        child: const Text('Save'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _saveSignature(Uint8List data) async {
    try {
      // 파일 이름 생성
      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final fileName = '$userId$timestamp.png';

      // 스토리지 경로
      final storagePath = '$workRoomId/$fileName';

      // Supabase 스토리지 업로드
      final String? uploadedFilePath = await Supabase.instance.client.storage
          .from('work_room_signatures')
          .uploadBinary(storagePath, data, fileOptions: const FileOptions(contentType: 'image/png'));

      if (uploadedFilePath == null) {
        throw Exception('Failed to upload signature: Upload returned null.');
      }

      print('Signature uploaded to: $storagePath');

      // ✅ 컨트롤러를 통해 DB에 서명 정보 저장
      await mySignatureController.saveSignatureToDatabase(userId, workRoomId, storagePath);

    } catch (e) {
      print('Error saving signature: $e');
    }
  }
}


// ===== FILE: ./lib/features/confidentiality/presentation/widgets/agreement_confirmation.dart =====



// ===== FILE: ./lib/features/confidentiality/presentation/widgets/agreement_form.dart =====



// ===== FILE: ./lib/features/friend/friend_list_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/friend/data/friend_model.dart';
import 'package:legalfactfinder2025/features/friend/data/friend_list_repository.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class FriendListController extends GetxController {
  final FriendListRepository repository = FriendListRepository(Supabase.instance.client);

  var isLoading = false.obs;
  var errorMessage = ''.obs;
  var friends = <Friend>[].obs;

  // ✅ 친구 목록 가져오기
  Future<void> fetchFriends(String userId) async {
    try {
      isLoading(true);
      errorMessage('');

      final result = await repository.getFriends(userId);
      friends.assignAll(result);
    } catch (e) {
      errorMessage('Failed to load friends.');
    } finally {
      isLoading(false);
    }
  }
}


// ===== FILE: ./lib/features/friend/data/friend_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'friend_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

Friend _$FriendFromJson(Map<String, dynamic> json) => Friend(
      username: json['username'] as String,
      isLawyer: json['isLawyer'] as bool,
      profilePictureUrl: json['profilePictureUrl'] as String,
      id: json['id'] as String,
    );

Map<String, dynamic> _$FriendToJson(Friend instance) => <String, dynamic>{
      'username': instance.username,
      'isLawyer': instance.isLawyer,
      'profilePictureUrl': instance.profilePictureUrl,
      'id': instance.id,
    };


// ===== FILE: ./lib/features/friend/data/friend_request_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'friend_request_model.g.dart';

@JsonSerializable()
class FriendRequest {
  final String id;
  final String requesterId;
  final String recipientId;
  final String status;
  final DateTime sentAt;
  final DateTime? respondedAt;

  FriendRequest({
    required this.id,
    required this.requesterId,
    required this.recipientId,
    required this.status,
    required this.sentAt,
    this.respondedAt,
  });

  factory FriendRequest.fromJson(Map<String, dynamic> json) => _$FriendRequestFromJson(json);

  Map<String, dynamic> toJson() => _$FriendRequestToJson(this);
}


// ===== FILE: ./lib/features/friend/data/friend_list_repository.dart =====

import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:legalfactfinder2025/features/friend/data/friend_model.dart';

class FriendListRepository {
  final SupabaseClient supabase;

  FriendListRepository(this.supabase);

  // ✅ 내 친구 목록 가져오기 (응답 구조 수정)
  Future<List<Friend>> getFriends(String userId) async {
    try {
      print("🔄 [FriendListRepository] Fetching friends for user ID: $userId");

      final startTime = DateTime.now(); // ✅ 요청 시작 시간 로깅
      print("⏳ [FriendListRepository] Requesting 'get_friends' from Supabase Edge Functions...");

      final response = await supabase.functions.invoke(
        'get_friends',
        body: {'user_id': userId},
      );

      final endTime = DateTime.now(); // ✅ 요청 종료 시간 로깅
      final duration = endTime.difference(startTime);
      print("✅ [FriendListRepository] Supabase Edge Function responded in ${duration.inMilliseconds}ms");

      // ✅ 응답이 Map 형태인지 확인
      if (response.data is! Map<String, dynamic>) {
        print("❌ [FriendListRepository] Unexpected API response format: ${response.data}");
        return [];
      }

      // ✅ `friends` 키가 존재하는지 확인 후 변환
      final jsonMap = response.data as Map<String, dynamic>;
      if (!jsonMap.containsKey('friends') || jsonMap['friends'] == null) {
        print("⚠️ [FriendListRepository] No friends found in response.");
        return [];
      }

      final List<dynamic> jsonList = jsonMap['friends'];
      final friends = jsonList.map((json) => Friend.fromJson(json)).toList();

      print("✅ [FriendListRepository] Successfully parsed ${friends.length} friends.");

      // ✅ 각 친구 정보 상세 로그
      for (var friend in friends) {
        print("👤 Friend - ID: ${friend.id}, Username: ${friend.username}, Is Lawyer: ${friend.isLawyer}, Profile URL: ${friend.profilePictureUrl}");
      }

      return friends;
    } catch (e, stacktrace) {
      print("❌ [FriendListRepository] Error fetching friends: $e");
      print("🔍 [FriendListRepository] Stacktrace: $stacktrace");
      throw Exception("Failed to fetch friends");
    }
  }
}


// ===== FILE: ./lib/features/friend/data/friend_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'friend_model.g.dart';


@JsonSerializable()
class Friend {
  final String username;
  final bool isLawyer;
  final String profilePictureUrl;
  final String id;

  Friend({
    required this.username,
    required this.isLawyer,
    required this.profilePictureUrl,
    required this.id,
  });

  factory Friend.fromJson(Map<String, dynamic> json) => _$FriendFromJson(json);

  Map<String, dynamic> toJson() => _$FriendToJson(this);
}
//flutter pub run build_runner build

// ===== FILE: ./lib/features/friend/data/friend_repository.dart =====



// ===== FILE: ./lib/features/friend/data/friend_request_repository.dart =====

import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/friend/data/friend_request_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class FriendRequestRepository {
  final SupabaseClient supabase;

  FriendRequestRepository(this.supabase);

  // ✅ Supabase Edge Function `put_friend_request` 호출하여 친구 요청 또는 초대 이메일 발송
  Future<bool> sendFriendRequest(String requesterId, String recipientEmail) async {
    try {
      print("🔄 Sending friend request from '$requesterId' to '$recipientEmail'");

      final responseEdge = await supabase.functions.invoke(
        'put_friend_request',
        body: {
          'requester_id': requesterId,
          'recipient_email': recipientEmail,
        },
      );

      if (responseEdge.data == null) {
        print("❌ No data received from Edge Function.");
        return false;
      }

      print("✅ Friend request successfully sent via Edge Function.");
      return true;
    } catch (e, stacktrace) {
      print("❌ Error sending friend request: $e");
      print("🔍 Stacktrace: $stacktrace");
      return false;
    }
  }


  // ✅ 받은 친구 요청 목록 불러오기
  Future<List<FriendRequest>> getReceivedFriendRequests(String userId) async {
    try {
      debugPrint("🔄 [FriendRequestRepository] Fetching received friend requests for user: $userId");

      final response = await supabase.functions.invoke(
        'get_received_friend_requests',
        body: {'user_id': userId},
      );

      if (response.data == null) {
        debugPrint("❌ [FriendRequestRepository] No data received.");
        return [];
      }

      // ✅ Ensure response.data is a List<dynamic>
      List<dynamic> responseData;
      if (response.data is String) {
        responseData = jsonDecode(response.data);
      } else if (response.data is List) {
        responseData = response.data;
      } else {
        throw Exception("Unexpected response format: ${response.data}");
      }

      debugPrint("✅ [FriendRequestRepository] Successfully fetched received friend requests.");
      return responseData.map((e) => FriendRequest.fromJson(e as Map<String, dynamic>)).toList();
    } catch (e) {
      debugPrint("❌ [FriendRequestRepository] Error fetching received requests: $e");
      return [];
    }
  }

  // ✅ 보낸 친구 요청 목록 불러오기
  Future<List<FriendRequest>> getSentFriendRequests(String userId) async {
    try {
      debugPrint("🔄 [FriendRequestRepository] Fetching sent friend requests for user: $userId");

      final response = await supabase.functions.invoke(
        'get_sent_friend_requests',
        body: {'user_id': userId},
      );

      if (response.data == null) {
        debugPrint("❌ [FriendRequestRepository] No data received.");
        return [];
      }

      // ✅ Ensure response.data is a List<dynamic>
      List<dynamic> responseData;
      if (response.data is String) {
        responseData = jsonDecode(response.data);
      } else if (response.data is List) {
        responseData = response.data;
      } else {
        throw Exception("Unexpected response format: ${response.data}");
      }

      debugPrint("✅ [FriendRequestRepository] Successfully fetched sent friend requests.");
      return responseData.map((e) => FriendRequest.fromJson(e as Map<String, dynamic>)).toList();
    } catch (e) {
      debugPrint("❌ [FriendRequestRepository] Error fetching sent requests: $e");
      return [];
    }
  }
}


// ===== FILE: ./lib/features/friend/data/friend_request_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'friend_request_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

FriendRequest _$FriendRequestFromJson(Map<String, dynamic> json) =>
    FriendRequest(
      id: json['id'] as String,
      requesterId: json['requesterId'] as String,
      recipientId: json['recipientId'] as String,
      status: json['status'] as String,
      sentAt: DateTime.parse(json['sentAt'] as String),
      respondedAt: json['respondedAt'] == null
          ? null
          : DateTime.parse(json['respondedAt'] as String),
    );

Map<String, dynamic> _$FriendRequestToJson(FriendRequest instance) =>
    <String, dynamic>{
      'id': instance.id,
      'requesterId': instance.requesterId,
      'recipientId': instance.recipientId,
      'status': instance.status,
      'sentAt': instance.sentAt.toIso8601String(),
      'respondedAt': instance.respondedAt?.toIso8601String(),
    };


// ===== FILE: ./lib/features/friend/friend_request_controller.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/friend/data/friend_request_model.dart';
import 'package:legalfactfinder2025/features/friend/data/friend_request_repository.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class FriendRequestController extends GetxController {
  final FriendRequestRepository repository = FriendRequestRepository(Supabase.instance.client);

  var isLoading = false.obs;
  var successMessage = ''.obs;
  var errorMessage = ''.obs;
  var receivedRequests = <Map<String, dynamic>>[].obs;
  var sentRequests = <Map<String, dynamic>>[].obs;

  // ✅ 친구 요청 보내기 (로그 추가)
  Future<void> sendFriendRequest(String requesterId, String recipientEmail) async {
    try {
      print("🔄 [FriendRequestController] Sending friend request from '$requesterId' to '$recipientEmail'");

      isLoading(true);
      successMessage('');
      errorMessage('');

      final startTime = DateTime.now(); // ✅ 요청 시작 시간 로깅
      print("⏳ [FriendRequestController] Calling repository.sendFriendRequest...");

      final success = await repository.sendFriendRequest(requesterId, recipientEmail);

      final endTime = DateTime.now(); // ✅ 요청 종료 시간 로깅
      final duration = endTime.difference(startTime);
      print("✅ [FriendRequestController] API call completed in ${duration.inMilliseconds}ms");

      if (success) {
        successMessage('Friend request sent successfully.');
        print("📨 [FriendRequestController] Friend request successfully sent to $recipientEmail");
      } else {
        errorMessage('Failed to send friend request. User may not exist.');
        print("❌ [FriendRequestController] Friend request failed: User not found or another issue.");
      }
    } catch (e, stacktrace) {
      errorMessage('Error sending friend request.');
      print("❌ [FriendRequestController] Exception occurred while sending friend request: $e");
      print("🔍 [FriendRequestController] Stacktrace: $stacktrace");
    } finally {
      isLoading(false);
      print("🔄 [FriendRequestController] Finished processing friend request.");
    }
  }

  // ✅ 받은 친구 요청 목록 불러오기
  Future<void> fetchReceivedFriendRequests(String userId) async {
    try {
      debugPrint("🔄 [FriendRequestController] Fetching received friend requests for user: $userId");

      isLoading(true);
      errorMessage('');

      List<FriendRequest> requests = await repository.getReceivedFriendRequests(userId);
      receivedRequests.assignAll(requests.map((e) => e.toJson()).toList()); // ✅ FIXED

      debugPrint("✅ [FriendRequestController] Successfully fetched received friend requests.");
    } catch (e, stacktrace) {
      errorMessage('❌ Error fetching received friend requests');
      debugPrint("❌ Exception: $e");
      debugPrint("🔍 Stacktrace: $stacktrace");
    } finally {
      isLoading(false);
    }
  }

  // ✅ 보낸 친구 요청 목록 불러오기
  Future<void> fetchSentFriendRequests(String userId) async {
    try {
      debugPrint("🔄 [FriendRequestController] Fetching sent friend requests for user: $userId");

      isLoading(true);
      errorMessage('');

      List<FriendRequest> requests = await repository.getSentFriendRequests(userId);
      sentRequests.assignAll(requests.map((e) => e.toJson()).toList()); // ✅ FIXED

      debugPrint("✅ [FriendRequestController] Successfully fetched sent friend requests.");
    } catch (e, stacktrace) {
      errorMessage('❌ Error fetching sent friend requests');
      debugPrint("❌ Exception: $e");
      debugPrint("🔍 Stacktrace: $stacktrace");
    } finally {
      isLoading(false);
    }
  }
}


// ===== FILE: ./lib/features/friend/domain/search_user_usecase.dart =====



// ===== FILE: ./lib/features/friend/domain/accept_friend_request_usecase.dart =====



// ===== FILE: ./lib/features/friend/domain/send_friend_request_usecase.dart =====



// ===== FILE: ./lib/features/friend/domain/fetch_friends_usecase.dart =====



// ===== FILE: ./lib/features/friend/presentation/recieved_friend_request_list_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/friend/friend_request_controller.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class RecievedFriendRequestListScreen extends StatefulWidget {
  @override
  _RecievedFriendRequestListScreenState createState() => _RecievedFriendRequestListScreenState();
}

class _RecievedFriendRequestListScreenState extends State<RecievedFriendRequestListScreen> {
  final FriendRequestController controller = Get.put(FriendRequestController());

  @override
  void initState() {
    super.initState();

    // Ensure the API call happens after the widget is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final userId = Supabase.instance.client.auth.currentUser?.id;
      if (userId != null) {
        controller.fetchReceivedFriendRequests(userId);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      if (controller.isLoading.value) {
        return const Center(child: CircularProgressIndicator());
      }
      if (controller.errorMessage.isNotEmpty) {
        return Center(child: Text(controller.errorMessage.value));
      }
      if (controller.receivedRequests.isEmpty) {
        return _buildEmptyState();
      }
      return ListView.builder(
        itemCount: controller.receivedRequests.length,
        itemBuilder: (context, index) {
          final request = controller.receivedRequests[index];
          return ListTile(
            leading: const Icon(Icons.person_add, color: Colors.blue),
            title: Text("From: ${request['requester_id']}"),
            trailing: _buildRequestActions(request['id']),
          );
        },
      );
    });
  }

  // ✅ 친구 요청 수락/거절 버튼
  Widget _buildRequestActions(String requestId) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          icon: const Icon(Icons.check, color: Colors.green),
          onPressed: () {
            print("✅ Accepted friend request: $requestId");
            // TODO: 친구 요청 수락 처리 로직 추가
          },
        ),
        IconButton(
          icon: const Icon(Icons.close, color: Colors.red),
          onPressed: () {
            print("❌ Declined friend request: $requestId");
            // TODO: 친구 요청 거절 처리 로직 추가
          },
        ),
      ],
    );
  }

  // ✅ 받은 친구 요청이 없을 때의 UI
  Widget _buildEmptyState() {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.person_off, size: 80, color: Colors.grey),
          SizedBox(height: 16),
          Text(
            "No received friend requests",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          SizedBox(height: 10),
          Text(
            "You haven't received any friend requests yet.",
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 14, color: Colors.grey),
          ),
        ],
      ),
    );
  }
}


// ===== FILE: ./lib/features/friend/presentation/friend_list_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/friend/friend_list_controller.dart';
import 'package:legalfactfinder2025/features/friend/presentation/friend_request_page.dart';
import 'package:legalfactfinder2025/features/friend/presentation/friend_requests_page.dart';
import 'package:legalfactfinder2025/features/profile/presentation/profile_page.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class FriendListScreen extends StatelessWidget {
  final FriendListController controller = Get.put(FriendListController());

  FriendListScreen({super.key});

  @override
  Widget build(BuildContext context) {
    // ✅ 현재 로그인된 사용자 ID 가져오기
    final userId = Supabase.instance.client.auth.currentUser?.id;
    if (userId == null) {
      return const Center(child: Text("Please log in to see your friends."));
    }

    controller.fetchFriends(userId); // ✅ 친구 목록 불러오기

    return Scaffold(
      body: Stack(
        children: [
          Positioned.fill(
            child: Obx(() {
              if (controller.isLoading.value) {
                return const Center(child: CircularProgressIndicator());
              }
              if (controller.errorMessage.isNotEmpty) {
                return Center(child: Text(controller.errorMessage.value));
              }
              if (controller.friends.isEmpty) {
                return _buildEmptyState(); // ✅ 친구가 없을 때의 UI 추가
              }
              return Column(
                children: [
                  Expanded(
                    child: ListView.separated(
                      itemCount: controller.friends.length,
                      separatorBuilder: (context, index) => const Divider(
                        thickness: 1,
                        height: 1,
                      ),
                      itemBuilder: (context, index) {
                        final friend = controller.friends[index];
                        return InkWell(
                          onTap: () {
                            Get.to(() => ProfilePage(), arguments: friend.id);
                          },
                          child: Padding(
                            padding: const EdgeInsets.symmetric(
                                vertical: 12, horizontal: 16),
                            child: Row(
                              children: [
                                CircleAvatar(
                                  backgroundImage:
                                  NetworkImage(friend.profilePictureUrl),
                                ),
                                const SizedBox(width: 12),
                                Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: [
                                    Text(
                                      friend.username,
                                      style: Theme.of(context).textTheme.titleMedium,
                                      maxLines: 1,
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                    const SizedBox(height: 4),
                                    Text(
                                      friend.isLawyer ? 'Lawyer' : 'Not a Lawyer',
                                      style: Theme.of(context).textTheme.bodyMedium,
                                    ),
                                  ],
                                ),
                              ],
                            ),
                          ),
                        );
                      },
                    ),
                  ),
                ],
              );
            }),
          ),
          Positioned(
            bottom: 16.0,
            right: 16.0,
            child: FloatingActionButton(
              onPressed: () {
                _navigateToFriendRequests();
              },
              child: const Icon(Icons.person_add_alt_1),
              tooltip: "View Friend Requests",
            ),
          ),
        ],
      ),
    );
  }

  void _navigateToFriendRequests() {
    Get.to(() => FriendRequestsPage());
  }

  // ✅ 친구 목록이 없을 때의 UI
  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Image.asset(
            'assets/images/friend_placeholder.png', // ✅ 친구 없음 이미지 추가
            width: 200,
            height: 200,
          ),
          const SizedBox(height: 20),
          const Text(
            "아직 친구가 없습니다!",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 10),
          const Text(
            "친구를 추가하고 함께 법률 문제를 논의하세요.",
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 14, color: Colors.grey),
          ),
          const SizedBox(height: 20),

          // ✅ Work Room 생성 버튼
          SizedBox(
            width: 200,
            child: ElevatedButton(
              onPressed: () {
                Get.to(() => FriendRequestPage()); // Work Room 생성 페이지 이동
              },
              child: const Text("내 첫 친구 추가하기"),
            ),
          ),
        ],
      ),
    );
  }
}


// ===== FILE: ./lib/features/friend/presentation/friend_request_page.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/friend/friend_request_controller.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class FriendRequestPage extends StatelessWidget {
  final FriendRequestController controller = Get.put(FriendRequestController());
  final TextEditingController emailController = TextEditingController();

  FriendRequestPage({super.key});

  @override
  Widget build(BuildContext context) {
    // ✅ 현재 로그인된 사용자 ID 가져오기
    final requesterId = Supabase.instance.client.auth.currentUser?.id;
    if (requesterId == null) {
      return const Center(child: Text("Please log in to send friend requests."));
    }

    return Scaffold(
      appBar: AppBar(title: const Text("Send Friend Request")),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              "Enter the email address of the user you want to add as a friend.",
              style: TextStyle(fontSize: 16),
            ),
            const SizedBox(height: 10),
            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              decoration: const InputDecoration(
                labelText: "User Email",
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 20),

            Obx(() {
              return controller.isLoading.value
                  ? const Center(child: CircularProgressIndicator())
                  : SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    final recipientEmail = emailController.text.trim();
                    if (recipientEmail.isEmpty) {
                      Get.snackbar("Error", "Please enter an email address.");
                      return;
                    }
                    controller.sendFriendRequest(requesterId, recipientEmail);
                  },
                  child: const Text("Send Request"),
                ),
              );
            }),

            const SizedBox(height: 20),

            // ✅ 성공 메시지 표시
            Obx(() {
              if (controller.successMessage.isNotEmpty) {
                return Text(
                  controller.successMessage.value,
                  style: const TextStyle(color: Colors.green, fontSize: 16),
                );
              }
              return const SizedBox.shrink();
            }),

            // ✅ 오류 메시지 표시
            Obx(() {
              if (controller.errorMessage.isNotEmpty) {
                return Text(
                  controller.errorMessage.value,
                  style: const TextStyle(color: Colors.red, fontSize: 16),
                );
              }
              return const SizedBox.shrink();
            }),
          ],
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/friend/presentation/sent_friend_request_list_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/friend/friend_request_controller.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class SentFriendRequestListScreen extends StatefulWidget {
  @override
  _SentFriendRequestListScreenState createState() => _SentFriendRequestListScreenState();
}

class _SentFriendRequestListScreenState extends State<SentFriendRequestListScreen> {
  final FriendRequestController controller = Get.put(FriendRequestController());

  @override
  void initState() {
    super.initState();

    // Ensure the API call happens after the widget is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final userId = Supabase.instance.client.auth.currentUser?.id;
      if (userId != null) {
        controller.fetchSentFriendRequests(userId);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      if (controller.isLoading.value) {
        return const Center(child: CircularProgressIndicator());
      }
      if (controller.errorMessage.isNotEmpty) {
        return Center(child: Text(controller.errorMessage.value));
      }
      if (controller.sentRequests.isEmpty) {
        return _buildEmptyState();
      }
      return ListView.builder(
        itemCount: controller.sentRequests.length,
        itemBuilder: (context, index) {
          final request = controller.sentRequests[index];
          return ListTile(
            leading: const Icon(Icons.send, color: Colors.blue),
            title: Text("To: ${request['recipient_id'] ?? request['recipient_email']}"),
            trailing: _buildRequestActions(request['id']),
          );
        },
      );
    });
  }

  // ✅ 친구 요청 취소 버튼
  Widget _buildRequestActions(String requestId) {
    return IconButton(
      icon: const Icon(Icons.cancel, color: Colors.red),
      onPressed: () {
        print("❌ Canceled friend request: $requestId");
        // TODO: 친구 요청 취소 처리 로직 추가
      },
    );
  }

  // ✅ 보낸 친구 요청이 없을 때의 UI
  Widget _buildEmptyState() {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.outgoing_mail, size: 80, color: Colors.grey),
          SizedBox(height: 16),
          Text(
            "No sent friend requests",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          SizedBox(height: 10),
          Text(
            "You haven't sent any friend requests yet.",
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 14, color: Colors.grey),
          ),
        ],
      ),
    );
  }
}


// ===== FILE: ./lib/features/friend/presentation/friend_requests_page.dart =====

import 'package:flutter/material.dart';
import 'recieved_friend_request_list_screen.dart';
import 'sent_friend_request_list_screen.dart';

class FriendRequestsPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 2,
      child: Scaffold(
        appBar: AppBar(
          title: const Text("Friend Requests"),
          bottom: const TabBar(
            tabs: [
              Tab(icon: Icon(Icons.inbox), text: "Received"),
              Tab(icon: Icon(Icons.send), text: "Sent"),
            ],
          ),
        ),
        body: TabBarView(
          children: [
            RecievedFriendRequestListScreen(),
            SentFriendRequestListScreen(),
          ],
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/friend/presentation/widgets/friend_request_card.dart =====



// ===== FILE: ./lib/features/friend/presentation/widgets/friend_card.dart =====



// ===== FILE: ./lib/features/friend/presentation/widgets/search_user_field.dart =====



// ===== FILE: ./lib/features/friend/friend_controller.dart =====



// ===== FILE: ./lib/features/calendar/calendar_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/calendar/data/calendar_event_model.dart';
import 'package:legalfactfinder2025/features/calendar/data/calendar_repository.dart';


class CalendarController extends GetxController {
  final CalendarRepository repository = CalendarRepository();

  var events = <CalendarEvent>[].obs;

  @override
  void onInit() {
    super.onInit();
    loadEvents();
  }

  void loadEvents() {
    events.value = repository.getEvents();
  }

  void addEvent(CalendarEvent event) {
    repository.addEvent(event);
    loadEvents();
  }

  void updateEvent(String id, CalendarEvent updatedEvent) {
    repository.updateEvent(id, updatedEvent);
    loadEvents();
  }

  void deleteEvent(String id) {
    repository.deleteEvent(id);
    loadEvents();
  }
}


// ===== FILE: ./lib/features/calendar/data/calendar_event_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'calendar_event_model.g.dart';

@JsonSerializable()
class CalendarEvent {
  final String id;
  final String title;
  final String description;
  final DateTime startDate;
  final DateTime endDate;

  CalendarEvent({
    required this.id,
    required this.title,
    required this.description,
    required this.startDate,
    required this.endDate,
  });

  factory CalendarEvent.fromJson(Map<String, dynamic> json) =>
      _$CalendarEventFromJson(json);

  Map<String, dynamic> toJson() => _$CalendarEventToJson(this);
}


// ===== FILE: ./lib/features/calendar/data/calendar_event_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'calendar_event_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

CalendarEvent _$CalendarEventFromJson(Map<String, dynamic> json) =>
    CalendarEvent(
      id: json['id'] as String,
      title: json['title'] as String,
      description: json['description'] as String,
      startDate: DateTime.parse(json['startDate'] as String),
      endDate: DateTime.parse(json['endDate'] as String),
    );

Map<String, dynamic> _$CalendarEventToJson(CalendarEvent instance) =>
    <String, dynamic>{
      'id': instance.id,
      'title': instance.title,
      'description': instance.description,
      'startDate': instance.startDate.toIso8601String(),
      'endDate': instance.endDate.toIso8601String(),
    };


// ===== FILE: ./lib/features/calendar/data/calendar_repository.dart =====

import 'calendar_event_model.dart';

class CalendarRepository {
  final List<CalendarEvent> _events = [];

  List<CalendarEvent> getEvents() {
    return _events;
  }

  void addEvent(CalendarEvent event) {
    _events.add(event);
  }

  void updateEvent(String id, CalendarEvent updatedEvent) {
    final index = _events.indexWhere((e) => e.id == id);
    if (index != -1) {
      _events[index] = updatedEvent;
    }
  }

  void deleteEvent(String id) {
    _events.removeWhere((e) => e.id == id);
  }
}


// ===== FILE: ./lib/features/calendar/domain/add_event_usecase.dart =====



// ===== FILE: ./lib/features/calendar/domain/update_event_usecase.dart =====



// ===== FILE: ./lib/features/calendar/domain/delete_event_usecase.dart =====



// ===== FILE: ./lib/features/calendar/presentation/calendar_screen.dart =====

import 'package:flutter/material.dart';
import 'package:table_calendar/table_calendar.dart';

class CalendarScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Expanded(
          child: TableCalendar(
            firstDay: DateTime.utc(2000, 1, 1),
            lastDay: DateTime.utc(2100, 12, 31),
            focusedDay: DateTime.now(),
            calendarStyle: const CalendarStyle(
              markerDecoration: BoxDecoration(
                color: Colors.blue,
                shape: BoxShape.circle,
              ),
            ),
            onDaySelected: (selectedDay, focusedDay) {
              // Handle day selection
            },
          ),
        ),
        const Padding(
          padding: EdgeInsets.all(16.0),
          child: Text(
            'Additional information below the calendar.',
            textAlign: TextAlign.center,
          ),
        ),
      ],
    );
  }
}


// ===== FILE: ./lib/features/calendar/presentation/widgets/calendar_view.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/calendar/calendar_controller.dart';
import 'package:table_calendar/table_calendar.dart';


class CalendarView extends StatelessWidget {
  final CalendarController controller;

  const CalendarView({Key? key, required this.controller}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return TableCalendar(
      focusedDay: DateTime.now(),
      firstDay: DateTime(2000),
      lastDay: DateTime(2100),
      eventLoader: (day) {
        return controller.events
            .where((event) => isSameDay(event.startDate, day))
            .toList();
      },
      calendarStyle: const CalendarStyle(
        markerDecoration: BoxDecoration(color: Colors.blue, shape: BoxShape.circle),
      ),
      onDaySelected: (selectedDay, focusedDay) {
        // Handle day selection
      },
    );
  }
}


// ===== FILE: ./lib/features/calendar/presentation/widgets/calendar_event_tile.dart =====

import 'package:flutter/material.dart';
import '../../data/calendar_event_model.dart';

class CalendarEventTile extends StatelessWidget {
  final CalendarEvent event;

  const CalendarEventTile({Key? key, required this.event}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(event.title),
      subtitle: Text(
        '${event.startDate} - ${event.endDate}',
        style: const TextStyle(fontSize: 12),
      ),
      trailing: IconButton(
        icon: const Icon(Icons.delete, color: Colors.red),
        onPressed: () {
          // Handle delete
        },
      ),
    );
  }
}


// ===== FILE: ./lib/features/chat/message_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/chat/data/message_model.dart';
import 'package:legalfactfinder2025/features/chat/data/message_repository.dart';

class MessageController extends GetxController {
  final MessageRepository _chatRepository;

  MessageController(this._chatRepository);

  // Observable for regular messages
  var messages = <Message>[].obs;
  var isLoading = false.obs; // Loading state for regular messages

  // Fetch messages for a work room
  Future<void> loadMessages(String workRoomId, {int limit = 20, int offset = 0}) async {
    print('loadMessages with workRoomId : '  + workRoomId);
    isLoading.value = true; // Start loading
    try {
      final fetchedMessages = await _chatRepository.fetchMessages(
        workRoomId,
        limit: limit,
        offset: offset,
      );
      messages.value = fetchedMessages; // Update the observable list
    } catch (e) {
      print('Error loading messages: $e');
    } finally {
      isLoading.value = false; // End loading
    }
  }

  // Send a message to the work room
  Future<void> sendMessage({
    required String workRoomId,
    required String senderId,
    required String content,
  }) async {
    try {
      final newMessage = await _chatRepository.sendMessage(
        workRoomId: workRoomId,
        senderId: senderId,
        content: content,
      );
      messages.insert(0, newMessage); // Add the new message to the top of the list
    } catch (e) {
      print('Error sending message: $e');
    }
  }
}


// ===== FILE: ./lib/features/chat/thread_message_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/chat/data/message_model.dart';
import 'package:legalfactfinder2025/features/chat/data/thread_message_repository.dart';

class ThreadMessageController extends GetxController {
  final ThreadMessageRepository _repository;

  ThreadMessageController(this._repository);

  var threadMessages = <Message>[].obs;
  var parentMessage = Rxn<Message>(); // Observable for the parent message
  var isLoading = false.obs;

  // Fetch messages in a thread
  Future<void> loadThreadMessages(String parentMessageId) async {
    isLoading.value = true; // Start loading
    try {
      // Fetch thread messages
      final fetchedMessages = await _repository.fetchThreadMessages(parentMessageId);
      threadMessages.value = fetchedMessages;

      // Fetch the parent message
      final fetchedParentMessage = await _repository.fetchParentMessage(parentMessageId);
      parentMessage.value = fetchedParentMessage;
    } catch (e) {
      print('Error loading thread messages: $e');
    } finally {
      isLoading.value = false; // End loading
    }
  }

  // Send a message in a thread
  Future<void> sendThreadMessage({
    required String workRoomId,
    required String senderId,
    required String content,
    required String parentMessageId,
  }) async {
    try {
      final newMessage = await _repository.sendThreadMessage(
        workRoomId: workRoomId,
        senderId: senderId,
        content: content,
        parentMessageId: parentMessageId,
      );
      threadMessages.add(newMessage);
    } catch (e) {
      print('Error sending thread message: $e');
    }
  }
}


// ===== FILE: ./lib/features/chat/thread_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/chat/data/thread_model.dart';
import 'package:legalfactfinder2025/features/chat/data/thread_repository.dart';

class ThreadController extends GetxController {
  final ThreadRepository _threadRepository;

  ThreadController(this._threadRepository);

  // Observable for threads
  var threads = <Thread>[].obs;
  var isThreadsLoading = false.obs; // Loading state for threads

  // Fetch threads for a specific work room
  Future<void> loadThreads(String workRoomId) async {
    isThreadsLoading.value = true; // Start loading
    try {
      final fetchedThreads = await _threadRepository.fetchThreads(workRoomId);
      threads.value = fetchedThreads; // Update the observable list
    } catch (e) {
      print('Error loading threads: $e');
    } finally {
      isThreadsLoading.value = false; // End loading
    }
  }

  // Refresh threads for real-time updates
  Future<void> refreshThreads(String workRoomId) async {
    try {
      final refreshedThreads = await _threadRepository.fetchThreads(workRoomId);
      threads.value = refreshedThreads; // Update threads with refreshed data
    } catch (e) {
      print('Error refreshing threads: $e');
    }
  }
}


// ===== FILE: ./lib/features/chat/data/thread_model.dart =====

class Thread {
  final String id;
  final String parentMessageId;
  final String threadContent;
  final String? latestReplyContent;
  final String? latestReplySenderId;
  final DateTime? latestReplyUpdatedAt;
  final int threadCount;

  Thread({
    required this.id,
    required this.parentMessageId,
    required this.threadContent,
    this.latestReplyContent,
    this.latestReplySenderId,
    this.latestReplyUpdatedAt,
    required this.threadCount,
  });

  // Factory constructor to parse JSON data into a Thread object
  factory Thread.fromJson(Map<String, dynamic> json) {
    return Thread(
      id: json['id'],
      parentMessageId: json['parent_message_id'],
      threadContent: json['thread_content'],
      latestReplyContent: json['latest_reply_content'],
      latestReplySenderId: json['latest_reply_sender_id'],
      latestReplyUpdatedAt: json['latest_reply_updated_at'] != null
          ? DateTime.parse(json['latest_reply_updated_at'])
          : null,
      threadCount: json['thread_count'],
    );
  }

  // Convert Thread object to JSON
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'parent_message_id': parentMessageId,
      'thread_content': threadContent,
      'latest_reply_content': latestReplyContent,
      'latest_reply_sender_id': latestReplySenderId,
      'latest_reply_updated_at':
      latestReplyUpdatedAt?.toIso8601String(),
      'thread_count': threadCount,
    };
  }
}


// ===== FILE: ./lib/features/chat/data/thread_message_repository.dart =====

import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:legalfactfinder2025/features/chat/data/message_model.dart';

class ThreadMessageRepository {
  final String getThreadMessagesEdgeFunctionUrl;
  final String getParentMessageEdgeFunctionUrl; // New endpoint for parent message
  final String putThreadMessageEdgeFunctionUrl;
  final String jwtToken;

  ThreadMessageRepository({
    required this.getThreadMessagesEdgeFunctionUrl,
    required this.getParentMessageEdgeFunctionUrl,
    required this.putThreadMessageEdgeFunctionUrl,
    required this.jwtToken,
  });

  // Fetch messages in a thread
  Future<List<Message>> fetchThreadMessages(String parentMessageId) async {
    final uri = Uri.parse(
        '$getThreadMessagesEdgeFunctionUrl?parent_message_id=$parentMessageId');

    final response = await http.get(
      uri,
      headers: {
        'Authorization': 'Bearer $jwtToken',
        'Content-Type': 'application/json; charset=utf-8', // Ensure UTF-8 encoding
      },
    );

    if (response.statusCode == 200) {
      final decodedResponse = utf8.decode(response.bodyBytes);

      final List<dynamic> data = jsonDecode(decodedResponse);
      return data.map((messageJson) => Message.fromJson(messageJson)).toList();
    } else {
      throw Exception("Failed to fetch thread messages: ${response.body}");
    }
  }

  // Fetch the parent message
// Fetch the parent message
  Future<Message> fetchParentMessage(String parentMessageId) async {
    final uri = Uri.parse(getParentMessageEdgeFunctionUrl);

    // Log the request for debugging
    print("Fetching parent message with ID: $parentMessageId");

    final response = await http.post(
      uri,
      headers: {
        'Authorization': 'Bearer $jwtToken',
        'Content-Type': 'application/json; charset=utf-8', // Ensure UTF-8 encoding
      },
      body: jsonEncode({"message_id": parentMessageId}), // Send message_id in the body
    );

    // Log the response for debugging
    print("Response status: ${response.statusCode}");
    print("Response body: ${response.body}");

    if (response.statusCode == 200) {
      final decodedResponse = utf8.decode(response.bodyBytes);

      final data = jsonDecode(decodedResponse);
      return Message.fromJson(data);
    } else {
      throw Exception("Failed to fetch parent message: ${response.body}");
    }
  }

  // Send a message in a thread
  Future<Message> sendThreadMessage({
    required String workRoomId,
    required String senderId,
    required String content,
    required String parentMessageId,
  }) async {
    final uri = Uri.parse(putThreadMessageEdgeFunctionUrl);

    final response = await http.post(
      uri,
      headers: {
        'Authorization': 'Bearer $jwtToken',
        'Content-Type': 'application/json; charset=utf-8', // Ensure UTF-8 encoding
      },
      body: jsonEncode({
        "work_room_id": workRoomId,
        "sender_id": senderId,
        "content": content,
        "message_type": "text",
        "parent_message_id": parentMessageId,
      }),
    );

    if (response.statusCode == 200) {
      final decodedResponse = utf8.decode(response.bodyBytes);

      final responseData = jsonDecode(decodedResponse);
      return Message.fromJson(responseData[0]);
    } else {
      throw Exception("Failed to send thread message: ${response.body}");
    }
  }
}


// ===== FILE: ./lib/features/chat/data/message_repository.dart =====

import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:legalfactfinder2025/features/chat/data/message_model.dart';

class MessageRepository {
  final String getChatMessagesEdgeFunctionUrl; // Supabase Edge Function URL
  final String putChatMessageEdgeFunctionUrl;
  final String jwtToken;

  MessageRepository(
      {required this.getChatMessagesEdgeFunctionUrl,
      required this.putChatMessageEdgeFunctionUrl,
      required this.jwtToken});

  Future<List<Message>> fetchMessages(String workRoomId,
      {int limit = 20, int offset = 0}) async {
    final uri = Uri.parse(
        '$getChatMessagesEdgeFunctionUrl?work_room_id=$workRoomId&limit=$limit&offset=$offset');
    final response = await http.get(
      uri,
      headers: {
        'Authorization': 'Bearer $jwtToken',
        'Content-Type': 'application/json; charset=utf-8', // Ensure UTF-8 encoding
      },
    );

    if (response.statusCode == 200) {
      final decodedResponse = utf8.decode(response.bodyBytes);
      final  List<dynamic> data = jsonDecode(decodedResponse);
       return data.map((messageJson) => Message.fromJson(messageJson)).toList();
    } else {
      throw Exception('Failed to fetch messages: ${response.body}');
    }
  }

  Future<Message> sendMessage({
    required String workRoomId,
    required String senderId,
    required String content,
  }) async {
    // Validate input parameters
    if (workRoomId.isEmpty || senderId.isEmpty || content.isEmpty) {
      throw Exception(
          "Missing required parameters: workRoomId, senderId, or content");
    }

    final uri = Uri.parse(putChatMessageEdgeFunctionUrl);
    final requestBody = jsonEncode({
      "work_room_id": workRoomId,
      "sender_id": senderId,
      "content": content,
      "message_type": "text",
    });

    // Log the request for debugging
    print("Sending POST request to $uri with body: $requestBody");

    final response = await http.post(
      uri,
      headers: {
        'Authorization': 'Bearer $jwtToken',
        'Content-Type': 'application/json',
      },
      body: requestBody,
    );

    // Log the raw response for debugging
    print("Response status: ${response.statusCode}");
    print("Response body: ${response.body}");

    // Handle response
    if (response.statusCode == 200) {
      try {
        final decodedResponse = utf8.decode(response.bodyBytes);

        final responseData = jsonDecode(decodedResponse);
        return Message.fromJson(responseData[
            0]); // Assuming the response contains the inserted message
      } catch (e) {
        throw Exception("Failed to decode response: ${response.body}");
      }
    } else {
      // Try to parse error as JSON, otherwise return raw response
      try {
        final errorData = jsonDecode(response.body);
        throw Exception(
            "Failed to send message: ${errorData['error'] ?? response.body}");
      } catch (_) {
        throw Exception("Failed to send message: ${response.body}");
      }
    }
  }


}


// ===== FILE: ./lib/features/chat/data/thread_repository.dart =====

import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:legalfactfinder2025/features/chat/data/thread_model.dart';

class ThreadRepository {
  final String getThreadsEdgeFunctionUrl;
  final String jwtToken;

  ThreadRepository({
    required this.getThreadsEdgeFunctionUrl,
    required this.jwtToken,
  });

  // Fetch threads for a work room
  Future<List<Thread>> fetchThreads(String workRoomId) async {
    final uri = Uri.parse(getThreadsEdgeFunctionUrl);

    final response = await http.post(
      uri,
      headers: {
        'Authorization': 'Bearer $jwtToken',
        'Content-Type': 'application/json; charset=utf-8', // Ensure UTF-8 encoding
      },
      body: jsonEncode({"work_room_id": workRoomId}),
    );

    if (response.statusCode == 200) {
      final decodedResponse = utf8.decode(response.bodyBytes);

      final Map<String, dynamic> responseBody = jsonDecode(decodedResponse);
      final List<dynamic> threadsData = responseBody['threads'] ?? [];
      return threadsData.map((threadJson) => Thread.fromJson(threadJson)).toList();
    } else {
      throw Exception("Failed to fetch threads: ${response.body}");
    }
  }
}


// ===== FILE: ./lib/features/chat/data/message_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'message_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

Message _$MessageFromJson(Map<String, dynamic> json) => Message(
      id: json['id'] as String,
      workRoomId: json['workRoomId'] as String,
      senderId: json['senderId'] as String,
      parentMessageId: json['parentMessageId'] as String?,
      content: json['content'] as String,
      messageType: json['messageType'] as String,
      threadCount: (json['threadCount'] as num).toInt(),
      hasAttachments: json['hasAttachments'] as bool,
      attachmentFileStorageKey: json['attachmentFileStorageKey'] as String?,
      attachmentFileType: json['attachmentFileType'] as String?,
      highlight: json['highlight'] as String?,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      annotationId: json['annotationId'] as String?,
      ocrText: json['ocrText'] as String?,
      annotationImageStorageKey: json['annotationImageStorageKey'] as String?,
      isSystem: json['isSystem'] as bool,
      systemEventType: json['systemEventType'] as String?,
      replyToMessageId: json['replyToMessageId'] as String?,
      replyToMessageContent: json['replyToMessageContent'] as String?,
      replyToMessageSenderId: json['replyToMessageSenderId'] as String?,
      replyToMessageCreatedAt: json['replyToMessageCreatedAt'] == null
          ? null
          : DateTime.parse(json['replyToMessageCreatedAt'] as String),
      imageFileId: json['imageFileId'] as String?,
    );

Map<String, dynamic> _$MessageToJson(Message instance) => <String, dynamic>{
      'id': instance.id,
      'workRoomId': instance.workRoomId,
      'senderId': instance.senderId,
      'parentMessageId': instance.parentMessageId,
      'content': instance.content,
      'messageType': instance.messageType,
      'threadCount': instance.threadCount,
      'hasAttachments': instance.hasAttachments,
      'attachmentFileStorageKey': instance.attachmentFileStorageKey,
      'attachmentFileType': instance.attachmentFileType,
      'highlight': instance.highlight,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
      'annotationId': instance.annotationId,
      'ocrText': instance.ocrText,
      'annotationImageStorageKey': instance.annotationImageStorageKey,
      'isSystem': instance.isSystem,
      'systemEventType': instance.systemEventType,
      'replyToMessageId': instance.replyToMessageId,
      'replyToMessageContent': instance.replyToMessageContent,
      'replyToMessageSenderId': instance.replyToMessageSenderId,
      'replyToMessageCreatedAt':
          instance.replyToMessageCreatedAt?.toIso8601String(),
      'imageFileId': instance.imageFileId,
    };


// ===== FILE: ./lib/features/chat/data/chat_model.dart =====



// ===== FILE: ./lib/features/chat/data/message_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'message_model.g.dart';

@JsonSerializable()
class Message {
  final String id;
  final String workRoomId;
  final String senderId;
  final String? parentMessageId;
  final String content;
  final String messageType;
  final int threadCount;
  final bool hasAttachments;
  final String? attachmentFileStorageKey;
  final String? attachmentFileType;
  final String? highlight;
  final DateTime createdAt;
  final DateTime updatedAt;
  final String? annotationId;
  final String? ocrText;
  final String? annotationImageStorageKey;
  final bool isSystem;
  final String? systemEventType;
  final String? replyToMessageId;
  final String? replyToMessageContent;
  final String? replyToMessageSenderId;
  final DateTime? replyToMessageCreatedAt;
  final String? imageFileId;

  Message({
    required this.id,
    required this.workRoomId,
    required this.senderId,
    this.parentMessageId,
    required this.content,
    required this.messageType,
    required this.threadCount,
    required this.hasAttachments,
    this.attachmentFileStorageKey,
    this.attachmentFileType,
    this.highlight,
    required this.createdAt,
    required this.updatedAt,
    this.annotationId,
    this.ocrText,
    this.annotationImageStorageKey,
    required this.isSystem,
    this.systemEventType,
    this.replyToMessageId,
    this.replyToMessageContent,
    this.replyToMessageSenderId,
    this.replyToMessageCreatedAt,
    this.imageFileId,
  });

  // Null-safe factory method for JSON deserialization
  factory Message.fromJson(Map<String, dynamic> json) {
    return Message(
      id: json['id'] as String? ?? '', // Default to empty string if null
      workRoomId: json['work_room_id'] as String? ?? '',
      senderId: json['sender_id'] as String? ?? '',
      parentMessageId: json['parent_message_id'] as String?,
      content: json['content'] as String? ?? '',
      messageType: json['message_type'] as String? ?? 'text',
      threadCount: json['thread_count'] as int? ?? 0,
      hasAttachments: json['has_attachments'] as bool? ?? false,
      attachmentFileStorageKey: json['attachment_file_storage_key'] as String?,
      attachmentFileType: json['attachment_file_type'] as String?,
      highlight: json['highlight'] as String?,
      createdAt: DateTime.parse(json['created_at'] as String? ?? DateTime.now().toIso8601String()),
      updatedAt: DateTime.parse(json['updated_at'] as String? ?? DateTime.now().toIso8601String()),
      annotationId: json['annotation_id'] as String?,
      ocrText: json['ocr_text'] as String?,
      annotationImageStorageKey: json['annotation_image_file_storage_key'] as String?,
      isSystem: json['is_system'] as bool? ?? false,
      systemEventType: json['system_event_type'] as String?,
      replyToMessageId: json['reply_to_message_id'] as String?,
      replyToMessageContent: json['reply_to_message_content'] as String?,
      replyToMessageSenderId: json['reply_to_message_sender_id'] as String?,
      replyToMessageCreatedAt: json['reply_to_message_created_at'] == null
          ? null
          : DateTime.parse(json['reply_to_message_created_at'] as String),
      imageFileId: json['image_file_storage_key'] as String?,
    );
  }

  Map<String, dynamic> toJson() => _$MessageToJson(this);
}


// ===== FILE: ./lib/features/chat/domain/update_message_usecase.dart =====



// ===== FILE: ./lib/features/chat/domain/fetch_messages_usecase.dart =====



// ===== FILE: ./lib/features/chat/domain/send_message_usecase.dart =====



// ===== FILE: ./lib/features/chat/presentation/thread_screen.dart =====

import 'dart:io';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/chat/thread_message_controller.dart';
import 'package:legalfactfinder2025/features/chat/data/message_model.dart';
import 'package:legalfactfinder2025/features/chat/presentation/widgets/message_tile.dart';
import 'package:legalfactfinder2025/features/chat/presentation/widgets/message_input.dart';

class ThreadScreen extends StatelessWidget {
  final String parentMessageId;
  final String workRoomId;
  final Map<String, String> participantsMap;

  const ThreadScreen({
    Key? key,
    required this.parentMessageId,
    required this.workRoomId,
    required this.participantsMap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final ThreadMessageController threadMessageController = Get.find<ThreadMessageController>();

    // Load thread messages and parent message when the screen opens
    threadMessageController.loadThreadMessages(parentMessageId);

    return Column(
      children: [
        // Header
        Row(
          children: [
            IconButton(
              icon: const Icon(Icons.close),
              onPressed: () => Navigator.pop(context),
            ),
            const SizedBox(width: 8),
            const Text(
              "Thread",
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ],
        ),
        const Divider(),
        // Parent message display
        Obx(() {
          final parentMessage = threadMessageController.parentMessage.value;

          if (threadMessageController.isLoading.value && parentMessage == null) {
            return const Center(child: CircularProgressIndicator());
          }

          if (parentMessage == null) {
            return const Padding(
              padding: EdgeInsets.all(8.0),
              child: Text("Failed to load parent message."),
            );
          }

          return Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              MessageTile(
                message: parentMessage,
                participantsMap: participantsMap,
              ),
              const Divider(),
            ],
          );
        }),
        // Thread messages display
        Expanded(
          child: Obx(() {
            final threadMessages = threadMessageController.threadMessages;

            if (threadMessageController.isLoading.value) {
              return const Center(child: CircularProgressIndicator());
            }

            if (threadMessages.isEmpty) {
              return const Center(child: Text("No replies yet."));
            }

            return ListView.builder(
              itemCount: threadMessages.length,
              itemBuilder: (context, index) {
                final message = threadMessages[index];
                return MessageTile(
                  message: message,
                  participantsMap: participantsMap,
                );
              },
            );
          }),
        ),
        // Input field to reply to thread
        MessageInput(
          workRoomId: workRoomId,
          parentMessageId: parentMessageId,
          onSend: ({
            required String workRoomId,
            required String senderId,
            required String content,
            String? parentMessageId,
            List<File>? attachments,
          }) async {
            if (attachments != null && attachments.isNotEmpty) {
              // Handle attachments logic for threads
              for (final file in attachments) {
                // Upload logic here
              }
            }
            await threadMessageController.sendThreadMessage(
              workRoomId: workRoomId,
              senderId: senderId,
              content: content,
              parentMessageId: parentMessageId!,
            );
          },
        ),

      ],
    );
  }
}


// ===== FILE: ./lib/features/chat/presentation/thread_list_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/chat/thread_controller.dart';
import 'package:legalfactfinder2025/features/chat/presentation/thread_screen.dart';

class ThreadListScreen extends StatelessWidget {
  final String workRoomId;
  final Map<String, String> participantsMap;

  const ThreadListScreen({
    Key? key,
    required this.workRoomId,
    required this.participantsMap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final ThreadController threadController = Get.find<ThreadController>();

    // Load threads when the screen opens
    threadController.loadThreads(workRoomId);

    return Column(
      children: [
        // Header
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            IconButton(
              icon: const Icon(Icons.close),
              onPressed: () => Navigator.pop(context),
            ),
            const Text(
              "Threads",
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
            const SizedBox(width: 48), // To balance the close button's space
          ],
        ),
        Expanded(
          child: Obx(() {
            final threads = threadController.threads;

            if (threads.isEmpty) {
              return const Center(child: Text("No threads available."));
            }

            return ListView.builder(
              itemCount: threads.length,
              itemBuilder: (context, index) {
                final thread = threads[index];

                return ListTile(
                  title: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        thread.threadContent,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                        style: const TextStyle(
                          fontWeight: FontWeight.bold,
                          fontSize: 16, // Emphasize the thread content
                        ),
                      ),
                      const SizedBox(height: 4),
                      if (thread.latestReplyContent != null) // Show the latest reply if available
                        Text(
                          "Latest: ${thread.latestReplyContent}",
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: const TextStyle(
                            color: Colors.grey,
                            fontSize: 14,
                          ),
                        ),
                    ],
                  ),
                  subtitle: Text(
                    "By: ${participantsMap[thread.latestReplySenderId] ?? 'Unknown'} • ${_formatTimestamp(thread.latestReplyUpdatedAt)}",
                    style: const TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                  onTap: () {
                    // Open thread screen
                    showModalBottomSheet(
                      context: context,
                      isScrollControlled: true,
                      shape: const RoundedRectangleBorder(
                        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
                      ),
                      builder: (context) => Container(
                        height: MediaQuery.of(context).size.height - 40,
                        child: ThreadScreen(
                          parentMessageId: thread.parentMessageId, // Pass the parent message ID
                          workRoomId: workRoomId,
                          participantsMap: participantsMap,
                        ),
                      ),
                    );
                  },
                );
              },
            );
          }),
        ),
      ],
    );
  }

  String _formatTimestamp(DateTime? timestamp) {
    if (timestamp == null) return "Unknown time";
    return "${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')} • ${timestamp.year}-${timestamp.month.toString().padLeft(2, '0')}-${timestamp.day.toString().padLeft(2, '0')}";
  }
}


// ===== FILE: ./lib/features/chat/presentation/chat_screen.dart =====

import 'dart:io';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/constants.dart';
import 'package:legalfactfinder2025/features/chat/message_controller.dart';
import 'package:legalfactfinder2025/features/chat/data/message_model.dart';
import 'package:legalfactfinder2025/features/chat/presentation/thread_screen.dart';
import 'package:legalfactfinder2025/features/chat/presentation/widgets/message_bubble.dart';
import 'package:legalfactfinder2025/features/chat/presentation/widgets/message_input.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_model.dart';

class ChatScreen extends StatefulWidget {
  final WorkRoom workRoom;
  final String myUserId;
  const ChatScreen({Key? key, required this.workRoom, required this.myUserId}) : super(key: key);

  @override
  _ChatScreenState createState() => _ChatScreenState();
}

class _ChatScreenState extends State<ChatScreen> {
  final MessageController _chatController = Get.find<MessageController>();
  final ScrollController _scrollController = ScrollController();
  String? _selectedMessageId;

  @override
  void initState() {
    super.initState();
    // Load messages for the workRoom when the screen initializes
    _chatController.loadMessages(widget.workRoom.id);
  }

  @override
  Widget build(BuildContext context) {
    // Create a map of participants (senderId to username)
    final participantsMap = {
      for (var participant in widget.workRoom.participants)
        participant.userId: participant.username
    };

    return Obx(() {
      if (_chatController.isLoading.value) {
        return const Center(child: CircularProgressIndicator());
      }

      final messages = _chatController.messages;

      return Column(
        children: [
          // Chat messages display
          Expanded(
            child: ListView.builder(
              controller: _scrollController,
              reverse: true,
              itemCount: messages.length,
              itemBuilder: (context, index) {
                final message = messages[index];
                return Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 12.0, vertical: 8),
                  child: MessageBubble(
                    myUserId: widget.myUserId,
                    message: message,
                    participantsMap: participantsMap,
                    isSelected: _selectedMessageId == message.id,
                    onSelected: (selectedMessageId) {
                      setState(() {
                        _selectedMessageId =
                        _selectedMessageId == selectedMessageId ? null : selectedMessageId;

                        if (_selectedMessageId != null) {
                          final selectedIndex = messages.indexWhere((msg) => msg.id == _selectedMessageId);
                          if (selectedIndex != -1) {
                            _scrollToMessage(selectedIndex);
                          }
                        }
                      });
                    },
                    onThread: (threadMessage) {
                      // Show thread for the selected message
                      showModalBottomSheet(
                        context: context,
                        isScrollControlled: true,
                        shape: const RoundedRectangleBorder(
                          borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
                        ),
                        builder: (context) => Container(
                          height: MediaQuery.of(context).size.height - 40,
                          child: ThreadScreen(parentMessageId: threadMessage.id, participantsMap: participantsMap, workRoomId: threadMessage.workRoomId,),
                        ),
                      );
                    },
                  ),
                );
              },
            ),
          ),
          // Input field for sending messages
          MessageInput(
            workRoomId: widget.workRoom.id,
            onSend: ({
              required String workRoomId,
              required String senderId,
              required String content,
              String? parentMessageId,
              List<File>? attachments,
            }) async {
              if (attachments != null && attachments.isNotEmpty) {
                // Handle attachments logic
                for (final file in attachments) {
                  // Upload logic here
                }
              }
              await _chatController.sendMessage(
                workRoomId: workRoomId,
                senderId: senderId,
                content: content,
              );
            },
          ),

        ],
      );
    });
  }

  void _scrollToMessage(int index) {
    final double position = index * 100.0; // Approximate height of each item
    _scrollController.animateTo(
      position,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeInOut,
    );
  }
}


// ===== FILE: ./lib/features/chat/presentation/chat_list.dart =====



// ===== FILE: ./lib/features/chat/presentation/widgets/chat_header.dart =====



// ===== FILE: ./lib/features/chat/presentation/widgets/message_tile.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/chat/data/message_model.dart';

class MessageTile extends StatelessWidget {
  final Message message;
  final Map<String, String> participantsMap; // Map of senderId to username

  const MessageTile({
    Key? key,
    required this.message,
    required this.participantsMap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // Get the sender's username from the participants map
    final username = participantsMap[message.senderId] ?? "Unknown User";

    return ListTile(
      leading: CircleAvatar(
        backgroundColor: Colors.grey[300],
        child: Text(
          username.isNotEmpty ? username[0].toUpperCase() : "?",
          style: const TextStyle(fontWeight: FontWeight.bold),
        ),
      ),
      title: Text(
        username,
        style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 14),
      ),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            message.content,
            style: const TextStyle(fontSize: 14),
          ),
          const SizedBox(height: 4),
          Text(
            _formatTimestamp(message.createdAt),
            style: const TextStyle(fontSize: 12, color: Colors.grey),
          ),
        ],
      ),
    );
  }

  String _formatTimestamp(DateTime timestamp) {
    // Format the timestamp into a readable format
    return "${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')} • ${timestamp.year}-${timestamp.month.toString().padLeft(2, '0')}-${timestamp.day.toString().padLeft(2, '0')}";
  }
}


// ===== FILE: ./lib/features/chat/presentation/widgets/message_bubble.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/constants.dart';
import 'package:legalfactfinder2025/features/chat/data/message_model.dart';
import 'package:legalfactfinder2025/features/chat/presentation/thread_screen.dart';

class MessageBubble extends StatelessWidget {
  final String myUserId;
  final Message message;
  final Map<String, String> participantsMap;
  final bool isSelected;
  final void Function(String)? onSelected;
  final void Function(Message)? onThread;
  final void Function(Message)? onReply;
  final void Function(Message)? onEdit;
  final void Function(Message)? onDelete;
  final void Function(Message)? onMarkImportant;


  const MessageBubble({
    Key? key,
    required this.myUserId,
    required this.message,
    required this.participantsMap,
    required this.isSelected,
    this.onSelected,
    this.onThread,
    this.onReply,
    this.onEdit,
    this.onDelete,
    this.onMarkImportant,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final isCurrentUser = message.senderId == myUserId;
    final alignment = isCurrentUser ? Alignment.centerRight : Alignment.centerLeft;
    final bubbleColor = isSelected
        ? (isCurrentUser ? Colors.blue.shade300 : Colors.grey.shade400)
        : (isCurrentUser ? Colors.blue : Colors.grey[300]);
    final textColor = isCurrentUser ? Colors.white : Colors.black;
    final username = participantsMap[message.senderId] ?? "Unknown";
    final time =
        "${message.createdAt.hour.toString().padLeft(2, '0')}:${message.createdAt.minute.toString().padLeft(2, '0')}";
    bool isImage = message.attachmentFileType?.startsWith('image') ?? false;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,

      children: [
        if (isImage)
          Image.network(message.attachmentFileStorageKey!, width: 200, height: 200, fit: BoxFit.cover)
        else
        Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: isCurrentUser ? MainAxisAlignment.end : MainAxisAlignment.start,
          children: [
            if (!isCurrentUser)
              Padding(
                padding: const EdgeInsets.only(left: 8, right: 8),
                child: CircleAvatar(
                  radius: 16,
                  backgroundImage: NetworkImage(
                    "https://via.placeholder.com/150",
                  ),
                  backgroundColor: Colors.grey[300],
                ),
              ),
            Column(
              crossAxisAlignment:
              isCurrentUser ? CrossAxisAlignment.end : CrossAxisAlignment.start,
              children: [
                if (!isCurrentUser)
                  Padding(
                    padding: const EdgeInsets.only(bottom: 2),
                    child: Text(
                      username,
                      style: const TextStyle(
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                        color: Colors.grey,
                      ),
                    ),
                  ),
                GestureDetector(
                  onTap: () => _showBottomSheet(context),
                  child: Container(
                    constraints: BoxConstraints(
                      maxWidth: MediaQuery.of(context).size.width * 0.8,
                    ),
                    margin: const EdgeInsets.symmetric(vertical: 2),
                    padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                    decoration: BoxDecoration(
                      color: bubbleColor,
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text(
                          message.content,
                          style: TextStyle(color: textColor),
                          softWrap: true,
                        ),
                        if (message.threadCount > 0) // Display thread count if greater than 0
                          GestureDetector(
                            onTap: () => _showThreadBottomSheet(context), // Open thread screen
                            child: Padding(
                              padding: const EdgeInsets.only(top: 4),
                              child: Text(
                                "Thread: ${message.threadCount}",
                                style: TextStyle(
                                  color: isCurrentUser ? Colors.white70 : Colors.blueAccent,
                                  fontSize: 12,
                                  fontWeight: FontWeight.bold,
                                  decoration: TextDecoration.underline,
                                ),
                              ),
                            ),
                          ),
                      ],
                    ),
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.only(top: 2),
                  child: Text(
                    time,
                    style: const TextStyle(
                      fontSize: 10,
                      color: Colors.grey,
                    ),
                  ),
                ),
              ],
            ),
          ],
        ),
      ],
    );
  }

  void _showBottomSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      builder: (context) {
        return Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildActionButton(
                context: context,
                icon: Icons.comment,
                label: "Thread",
                onTap: () {
                  Navigator.pop(context);
                  _showThreadBottomSheet(context);
                },
              ),
              _buildActionButton(
                context: context,
                icon: Icons.reply,
                label: "Reply",
                onTap: () {
                  Navigator.pop(context);
                  if (onReply != null) onReply!(message);
                },
              ),
              _buildActionButton(
                context: context,
                icon: Icons.edit,
                label: "Edit",
                onTap: () {
                  Navigator.pop(context);
                  if (onEdit != null) onEdit!(message);
                },
              ),
              _buildActionButton(
                context: context,
                icon: Icons.delete,
                label: "Delete",
                onTap: () {
                  Navigator.pop(context);
                  if (onDelete != null) onDelete!(message);
                },
              ),
              _buildActionButton(
                context: context,
                icon: Icons.star,
                label: "Mark Important",
                onTap: () {
                  Navigator.pop(context);
                  if (onMarkImportant != null) onMarkImportant!(message);
                },
              ),
            ],
          ),
        );
      },
    );
  }

  void _showThreadBottomSheet(BuildContext context) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      builder: (context) {
        return Container(
          height: MediaQuery.of(context).size.height - 40,
          child: ThreadScreen(
            parentMessageId: message.id,
            workRoomId: message.workRoomId,
            participantsMap: participantsMap,
          ),
        );
      },
    );
  }

  Widget _buildActionButton({
    required BuildContext context,
    required IconData icon,
    required String label,
    required VoidCallback onTap,
  }) {
    return ListTile(
      leading: Icon(icon, color: Colors.grey[700]),
      title: Text(
        label,
        style: const TextStyle(fontSize: 16, color: Colors.black),
      ),
      onTap: onTap,
    );
  }
}


// ===== FILE: ./lib/features/chat/presentation/widgets/message_popup_menu.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/chat/data/message_model.dart';

class MessagePopupMenu extends StatelessWidget {
  final bool isCurrentUser;
  final Message message;
  final void Function(Message)? onThreadWrite;
  final void Function(Message)? onReply;
  final void Function(Message)? onEdit;
  final void Function(Message)? onDelete;
  final void Function(Message)? onMarkImportant;

  const MessagePopupMenu({
    Key? key,
    required this.isCurrentUser,
    required this.message,
    this.onThreadWrite,
    this.onReply,
    this.onEdit,
    this.onDelete,
    this.onMarkImportant,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Positioned(
      top: 0,
      right: isCurrentUser ? -60 : null,
      left: isCurrentUser ? null : -60,
      child: Material(
        color: Colors.transparent,
        child: Container(
          padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
          decoration: BoxDecoration(
            color: Colors.white,
            border: Border.all(color: Colors.grey.shade400),
            borderRadius: BorderRadius.circular(8),
            boxShadow: [
              BoxShadow(
                color: Colors.black.withOpacity(0.1),
                blurRadius: 4,
                offset: const Offset(0, 2),
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              _buildCompactIcon(
                icon: Icons.comment,
                onTap: () {
                  if (onThreadWrite != null) onThreadWrite!(message);
                },
              ),
              _buildCompactIcon(
                icon: Icons.reply,
                onTap: () {
                  if (onReply != null) onReply!(message);
                },
              ),
              _buildCompactIcon(
                icon: Icons.edit,
                onTap: () {
                  if (onEdit != null) onEdit!(message);
                },
              ),
              _buildCompactIcon(
                icon: Icons.delete,
                onTap: () {
                  if (onDelete != null) onDelete!(message);
                },
              ),
              _buildCompactIcon(
                icon: Icons.star,
                onTap: () {
                  if (onMarkImportant != null) onMarkImportant!(message);
                },
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildCompactIcon({required IconData icon, required VoidCallback onTap}) {
    return GestureDetector(
      onTap: onTap,
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 2),
        child: Icon(
          icon,
          size: 14,
          color: Colors.grey[700],
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/chat/presentation/widgets/message_input.dart =====

import 'dart:io';
import 'package:flutter/material.dart';
import 'package:file_picker/file_picker.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/authentication/auth_controller.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class MessageInput extends StatefulWidget {
  final String workRoomId;
  final String? parentMessageId; // Optional for threads
  final Future<void> Function({
  required String workRoomId,
  required String senderId,
  required String content,
  String? parentMessageId,
  List<File>? attachments,
  }) onSend;

  const MessageInput({
    Key? key,
    required this.workRoomId,
    this.parentMessageId,
    required this.onSend,
  }) : super(key: key);

  @override
  _MessageInputState createState() => _MessageInputState();
}

class _MessageInputState extends State<MessageInput> {
  final TextEditingController _controller = TextEditingController();
  List<File> _selectedFiles = [];
  bool _isUploading = false;

  /// Selects files for upload
  Future<void> _pickFiles() async {
    FilePickerResult? result = await FilePicker.platform.pickFiles(
      allowMultiple: true,
      type: FileType.any,
    );

    if (result != null) {
      setState(() {
        _selectedFiles.addAll(result.files.map((file) => File(file.path!)));
      });
    }
  }

  /// Removes a file from the selection
  void _removeFile(int index) {
    setState(() {
      _selectedFiles.removeAt(index);
    });
  }

  /// Sends the message with optional attachments
  Future<void> _sendMessage() async {
    if (_controller.text.isEmpty && _selectedFiles.isEmpty) return;

    setState(() {
      _isUploading = true;
    });

    try {

      AuthController authController = Get.find<AuthController>();
      String? myUserId = authController.getUserId();
      if (myUserId == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text("User ID is null")),
        );
        Get.toNamed('/login');
        return;
      }


      await widget.onSend(
        workRoomId: widget.workRoomId,
        senderId: myUserId, // Replace with the current user's ID
        content: _controller.text.trim(),
        parentMessageId: widget.parentMessageId,
        attachments: _selectedFiles,
      );

      _controller.clear();
      setState(() {
        _selectedFiles.clear();
      });
    } catch (e) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("Failed to send message: $e")),
      );
    } finally {
      setState(() {
        _isUploading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.white,
        border: Border(top: BorderSide(color: Colors.grey.shade300)),
      ),
      child: Column(
        children: [
          if (_selectedFiles.isNotEmpty)
            SizedBox(
              height: 80,
              child: ListView.builder(
                scrollDirection: Axis.horizontal,
                itemCount: _selectedFiles.length,
                itemBuilder: (context, index) {
                  final file = _selectedFiles[index];
                  final fileName = file.path.split('/').last;

                  return Stack(
                    children: [
                      Padding(
                        padding: const EdgeInsets.all(4.0),
                        child: Container(
                          width: 60,
                          height: 60,
                          color: Colors.grey.shade300,
                          child: Center(
                            child: Text(
                              fileName.length > 10
                                  ? "${fileName.substring(0, 10)}..."
                                  : fileName,
                              textAlign: TextAlign.center,
                              style: const TextStyle(fontSize: 12),
                            ),
                          ),
                        ),
                      ),
                      Positioned(
                        right: 0,
                        top: 0,
                        child: GestureDetector(
                          onTap: () => _removeFile(index),
                          child: Container(
                            decoration: const BoxDecoration(
                              shape: BoxShape.circle,
                              color: Colors.red,
                            ),
                            child: const Icon(Icons.close, color: Colors.white, size: 16),
                          ),
                        ),
                      ),
                    ],
                  );
                },
              ),
            ),
          Row(
            children: [
              IconButton(
                icon: const Icon(Icons.attach_file, color: Colors.grey),
                onPressed: _pickFiles,
              ),
              Expanded(
                child: TextField(
                  controller: _controller,
                  decoration: InputDecoration(
                    hintText: "Type your message...",
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(16),
                      borderSide: BorderSide(color: Colors.grey.shade400),
                    ),
                    enabledBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(16),
                      borderSide: BorderSide(color: Colors.grey.shade300),
                    ),
                    focusedBorder: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(16),
                      borderSide: BorderSide(color: Colors.blue.shade300),
                    ),
                    contentPadding: const EdgeInsets.symmetric(
                      horizontal: 12,
                      vertical: 8,
                    ),
                  ),
                ),
              ),
              _isUploading
                  ? const Padding(
                padding: EdgeInsets.symmetric(horizontal: 8.0),
                child: CircularProgressIndicator(strokeWidth: 2),
              )
                  : IconButton(
                icon: const Icon(Icons.send, color: Colors.blue),
                onPressed: _sendMessage,
              ),
            ],
          ),
        ],
      ),
    );
  }
}


// ===== FILE: ./lib/features/notification/data/notification_repository.dart =====

import 'dart:convert';
import 'package:http/http.dart' as http;
import 'notification_model.dart';

class NotificationRepository {
  final String getUserNotificationsUrl; // Supabase Edge Function URL
  final String jwtToken;

  NotificationRepository({
    required this.getUserNotificationsUrl,
    required this.jwtToken,
  });

  /// Fetch notifications for a specific user
  Future<List<NotificationModel>> fetchNotifications(String userId) async {
    final uri = Uri.parse('$getUserNotificationsUrl');

    final requestBody = jsonEncode({"p_user_id": userId});

    // Log request details for debugging
    print("🔵 [REQUEST] Fetching notifications for userId: $userId");
    print("🔸 Request Body: $requestBody");

    try {
      final response = await http.post(
        uri,
        headers: {
          'Authorization': 'Bearer $jwtToken',
          'Content-Type': 'application/json',
        },
        body: requestBody,
      );

      // Log response status and body for debugging
      print("🟢 [RESPONSE] Status Code: ${response.statusCode}");
      print("🟢 [RESPONSE] Body: ${response.body}");

      if (response.statusCode == 200) {
        final decodedResponse = utf8.decode(response.bodyBytes);
        final responseData = jsonDecode(decodedResponse)['notifications'];

        // Log the number of notifications returned
        print("🟢 [SUCCESS] Fetched ${responseData.length} notifications");

        return (responseData as List)
            .map((notificationJson) => NotificationModel.fromJson(notificationJson))
            .toList();
      } else {
        // Log the error details
        print("❌ [ERROR] Failed to fetch notifications: ${response.body}");

        // Try to parse error details or throw a generic exception
        try {
          final errorData = jsonDecode(response.body);
          throw Exception(
              "Failed to fetch notifications: ${errorData['error'] ?? response.body}");
        } catch (_) {
          throw Exception("Failed to fetch notifications: ${response.body}");
        }
      }
    } catch (e, stackTrace) {
      // Log the exception and stack trace if there's an error
      print("🚨 [EXCEPTION] Error during fetch: $e");
      print("🔴 Stack Trace: $stackTrace");
      rethrow;
    }
  }

  /// Mark a notification as read
  Future<void> markNotificationAsRead(String notificationId) async {
    // Log when marking a notification as read
    print("🔵 [REQUEST] Marking notification as read: $notificationId");

    try {
      // Simulate marking the notification as read (actual API call can go here)
      print("🟢 [SUCCESS] Notification $notificationId marked as read");

      // In a real scenario, you'd make an API call to mark it as read
      // Example: await notificationRepository.markNotificationAsRead(notificationId);

    } catch (e, stackTrace) {
      // Log errors while marking the notification as read
      print("❌ [ERROR] Failed to mark notification $notificationId as read: $e");
      print("🔴 Stack Trace: $stackTrace");
    }
  }
}


// ===== FILE: ./lib/features/notification/data/notification_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'notification_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

NotificationModel _$NotificationModelFromJson(Map<String, dynamic> json) =>
    NotificationModel(
      id: json['id'] as String,
      userId: json['userId'] as String,
      notificationType: json['notificationType'] as String,
      relatedId: json['relatedId'] as String,
      content: json['content'] as String,
      isRead: json['isRead'] as bool,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      title: json['title'] as String,
    );

Map<String, dynamic> _$NotificationModelToJson(NotificationModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'userId': instance.userId,
      'notificationType': instance.notificationType,
      'relatedId': instance.relatedId,
      'content': instance.content,
      'isRead': instance.isRead,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
      'title': instance.title,
    };


// ===== FILE: ./lib/features/notification/data/notification_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'notification_model.g.dart';

@JsonSerializable()
class NotificationModel {
  final String id;
  final String userId;
  final String notificationType;
  final String relatedId;
  final String content;
  bool isRead;
  final DateTime createdAt;
  final DateTime updatedAt;
  final String title;

  NotificationModel({
    required this.id,
    required this.userId,
    required this.notificationType,
    required this.relatedId,
    required this.content,
    required this.isRead,
    required this.createdAt,
    required this.updatedAt,
    required this.title,
  });

  // Null-safe factory method for JSON deserialization
  factory NotificationModel.fromJson(Map<String, dynamic> json) {
    return NotificationModel(
      id: json['id'] as String? ?? '',
      userId: json['user_id'] as String? ?? '',
      notificationType: json['notification_type'] as String? ?? '',
      relatedId: json['related_id'] as String? ?? '',
      content: json['content'] as String? ?? '',
      isRead: json['is_read'] as bool? ?? false,
      createdAt: DateTime.tryParse(json['created_at'] as String? ?? '') ?? DateTime.now(),
      updatedAt: DateTime.tryParse(json['updated_at'] as String? ?? '') ?? DateTime.now(),
      title: json['title'] as String? ?? '',
    );
  }

  Map<String, dynamic> toJson() => _$NotificationModelToJson(this);
}


// ===== FILE: ./lib/features/notification/domain/fetch_notifications_usecase.dart =====

import '../data/notification_repository.dart';
import '../data/notification_model.dart';

class FetchNotificationsUseCase {
  final NotificationRepository repository;

  FetchNotificationsUseCase(this.repository);

  Future<List<NotificationModel>> call(String userId) {
    return repository.fetchNotifications(userId);
  }
}


// ===== FILE: ./lib/features/notification/domain/mark_notification_as_read_usecase.dart =====

import '../data/notification_repository.dart';

class MarkNotificationAsReadUseCase {
  final NotificationRepository repository;

  MarkNotificationAsReadUseCase(this.repository);

  Future<void> call(String notificationId) {
    return repository.markNotificationAsRead(notificationId);
  }
}


// ===== FILE: ./lib/features/notification/presentation/notification_list_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/constants.dart';
import 'package:legalfactfinder2025/features/authentication/auth_controller.dart';
import 'package:legalfactfinder2025/features/notification/data/notification_model.dart';
import 'package:legalfactfinder2025/features/notification/data/notification_repository.dart';

class NotificationListController extends GetxController {
  final NotificationRepository notificationRepository;

  NotificationListController({required this.notificationRepository});

  var notifications = <NotificationModel>[].obs;
  var isLoading = true.obs;

  @override
  void onInit() {
    super.onInit();
    print("🔄 NotificationListController initialized");
    // Uncomment if user authentication is needed
    // final AuthController authController = Get.find();
    // String? userId = authController.getUserId();
    //
    // if (userId == null) {
    //   print("🚨 User not logged in. Redirecting to login page.");
    //   Get.offAllNamed('/login');
    //   return;
    // }
    //
    // print("User ID: $userId");
    // fetchNotifications(userId); // Fetch notifications if userId is valid
  }

  Future<void> fetchNotifications() async {
    AuthController authController = Get.find<AuthController>();
    final userId = authController.getUserId(); // AuthController에서 userId 가져오기
    if (userId == null) {
      print("❌ Error: userId is null. Cannot fetch notifications.");
      return;
    }

    print("🔵 Fetching notifications for userId: $userId");

    isLoading(true); // Set loading state to true
    try {
      final data = await notificationRepository.fetchNotifications(userId);
      notifications.value = data;
      print("🟢 Successfully fetched ${data.length} notifications");
    } catch (e) {
      print("❌ Error fetching notifications: $e");
    } finally {
      isLoading(false); // Set loading state to false after operation is complete
      print("🔚 Fetching notifications completed.");
    }
  }

  Future<void> markAsRead(String notificationId) async {
    print("🔵 Marking notification as read: $notificationId");

    try {
      // Mark the notification as read in the repository
      await notificationRepository.markNotificationAsRead(notificationId);
      print("🟢 Notification marked as read: $notificationId");

      // Find the notification locally and update its status
      NotificationModel notification = notifications.firstWhere((n) => n.id == notificationId);
      notification.isRead = true;
      notifications.refresh(); // Refresh the notifications list to trigger UI update
      print("🟢 Notification status updated: $notificationId isRead = true");
    } catch (e) {
      print("❌ Error marking notification as read: $e");
    }
  }
}


// ===== FILE: ./lib/features/notification/presentation/widgets/notification_item_widget.dart =====

import 'package:flutter/material.dart';
import '../../data/notification_model.dart';

class NotificationItemWidget extends StatelessWidget {
  final NotificationModel notification;
  final VoidCallback onTap;

  const NotificationItemWidget({
    Key? key,
    required this.notification,
    required this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListTile(
      title: Text(notification.title),
      subtitle: Text(notification.content),
      trailing: notification.isRead
          ? const Icon(Icons.check_circle, color: Colors.green)
          : const Icon(Icons.circle, color: Colors.grey),
      onTap: onTap,
    );
  }
}


// ===== FILE: ./lib/features/notification/presentation/notification_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:intl/intl.dart'; // Date formatting
import 'notification_list_controller.dart';

class NotificationPage extends StatefulWidget {
  @override
  _NotificationPageState createState() => _NotificationPageState();
}

class _NotificationPageState extends State<NotificationPage> {
  final NotificationListController controller = Get.find<NotificationListController>();
  bool isLoading = true;

  @override
  void initState() {
    super.initState();
    _loadNotifications();
  }

  Future<void> _loadNotifications() async {
    await controller.fetchNotifications();
    setState(() {
      isLoading = false;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Notifications'),
      ),
      body: isLoading
          ? const Center(child: CircularProgressIndicator())
          : Obx(() {
        if (controller.notifications.isEmpty) {
          return const Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.notifications_off,
                  size: 80,
                  color: Colors.grey,
                ),
                SizedBox(height: 16),
                Text(
                  'No notifications available',
                  style: TextStyle(fontSize: 16, color: Colors.grey),
                ),
              ],
            ),
          );
        }

        return ListView.builder(
          itemCount: controller.notifications.length,
          itemBuilder: (context, index) {
            final notification = controller.notifications[index];

            // Date formatting
            final formattedDate =
            DateFormat('yyyy-MM-dd HH:mm').format(notification.createdAt);

            return ListTile(
              title: Row(
                children: [
                  Expanded(
                    child: Text(
                      notification.title,
                      maxLines: 1,
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                  Text(
                    formattedDate,
                    style: TextStyle(color: Colors.grey[600], fontSize: 12),
                  ),
                ],
              ),
              subtitle: Text(notification.content),
              onTap: () {
                controller.markAsRead(notification.id);
              },
            );
          },
        );
      }),
    );
  }
}


// ===== FILE: ./lib/features/document_annotation/annotation_controller.dart =====

import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/document_annotation/data/annotation_repository.dart';
import 'package:legalfactfinder2025/features/document_annotation/data/document_annotation_model.dart';

class AnnotationController extends GetxController {
  final AnnotationRepository _annotationRepository = AnnotationRepository();

  RxList<Map<String, dynamic>> annotations = RxList<Map<String, dynamic>>([]);
  RxBool isLoading = false.obs;
  RxString errorMessage = ''.obs;

  Future<void> fetchAnnotations(String parentFileStorageKey) async {
    try {
      isLoading.value = true;
      final fetchedAnnotations =
      await _annotationRepository.fetchAnnotations(parentFileStorageKey);
      annotations.value = fetchedAnnotations;
    } catch (e) {
      errorMessage.value = "Failed to fetch annotations: $e";
    } finally {
      isLoading.value = false;
    }
  }

  Future<bool> saveAnnotation({
    required String workRoomId,
    required String fileName,
    required int page,
    required Rect rect,
    required String text,
    Uint8List? imageBytes,
  }) async {
    try {
      bool success = await _annotationRepository.saveAnnotation(
        workRoomId: workRoomId,
        fileName: fileName,
        page: page,
        rect: rect,
        text: text,
        imageBytes: imageBytes,
      );

      if (success) {
        fetchAnnotations("$workRoomId/$fileName"); // ✅ 저장 후 최신 데이터 불러오기
      }
      return success;
    } catch (e) {
      errorMessage.value = "Failed to save annotation: $e";
      return false;
    }
  }
}


// ===== FILE: ./lib/features/document_annotation/data/annotation_repository.dart =====

import 'dart:convert';
import 'dart:typed_data';
import 'package:flutter/painting.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/authentication/auth_controller.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'package:intl/intl.dart';
import 'document_annotation_model.dart';
import 'package:legalfactfinder2025/constants.dart'; // ✅ constants.dart에서 가져옴
import 'package:http/http.dart' as http;

class AnnotationRepository {
  final SupabaseClient _supabase = Supabase.instance.client;

  /// 공통 로깅 함수
  void log(String level, String message) {
    const String reset = '\x1B[0m';
    const String infoColor = '\x1B[32m'; // 🟢 Green
    const String errorColor = '\x1B[31m'; // 🔴 Red
    const String warningColor = '\x1B[33m'; // 🟡 Yellow
    const String debugColor = '\x1B[34m'; // 🔵 Blue

    String prefix = switch (level) {
      'INFO' => '$infoColor🟢 [INFO]$reset',
      'ERROR' => '$errorColor🔴 [ERROR]$reset',
      'WARNING' => '$warningColor🟡 [WARNING]$reset',
      'DEBUG' => '$debugColor🔵 [DEBUG]$reset',
      _ => '[LOG]'
    };

    print('$prefix $message');
  }

  /// 📌 **주석 가져오기**
  Future<List<Map<String, dynamic>>> fetchAnnotations(String parentFileStorageKey) async {
    try {
      log('INFO', "Fetching annotations for parentFileStorageKey: $parentFileStorageKey...");

      final response = await _supabase.rpc(
        'get_document_annotations_by_parent_file_storage_key',
        params: { '_parent_file_storage_key': parentFileStorageKey },
      );

      if (response is List) {
        log('INFO', "✅ Successfully fetched annotations: ${response.length} records.");
        return List<Map<String, dynamic>>.from(response);
      } else {
        log('WARNING', "⚠️ Unexpected response format: ${response.runtimeType}");
        return [];
      }
    } catch (e, stackTrace) {
      log('ERROR', "❌ Error fetching annotations: $e");
      log('DEBUG', "🔍 Stack Trace: $stackTrace");
      rethrow;
    }
  }

  /// 📌 **주석 저장 (Database + Storage)**
  /// 📌 주석 저장 (Database + Storage)
  /// 📌 **주석 저장 (Edge Function 호출)**
  Future<bool> saveAnnotation({
    required String workRoomId,
    required String fileName,
    required int page,
    required Rect rect,
    required String text,
    Uint8List? imageBytes,
  }) async {
    try {
      log('INFO', "📝 Saving annotation via Edge Function...");

      final rectJson = DocumentAnnotationModel.rectToJson(rect);
      final String parentFileStorageKey = '$workRoomId/$fileName';

      log('INFO', "📂 Parent Storage Key: $parentFileStorageKey");

      String? imageFileStorageKey;
      if (imageBytes != null) {
        imageFileStorageKey =
        '$workRoomId/$fileName/page_${page}_${DateFormat('yyyyMMdd_HHmmss').format(DateTime.now().toUtc())}.png';
      }

      // Edge Function에 전송할 데이터
      Map<String, dynamic> annotationData = {
        'document_id': null,
        'parent_file_storage_key': parentFileStorageKey,
        'work_room_id': workRoomId,
        'page_number': page,
        'x1': rectJson['x1'],
        'y1': rectJson['y1'],
        'x2': rectJson['x2'],
        'y2': rectJson['y2'],
        'content': text,
        'annotation_type': 'manual',
        'image_file_storage_key': imageFileStorageKey,
        'is_ocr': false,
        'ocr_text': null,
        'created_by': '01ba12d0-da6a-45e0-8535-6d2e49a4f96e',
      };

      log('INFO', "📤 Sending annotation data to Edge Function...");
      final response = await http.post(
        Uri.parse(putDocumentAnnotationEdgeFunctionUrl), // ✅ constants.dart의 URL 사용
        headers: {
          'Authorization': 'Bearer $jwtToken',
          "Content-Type": "application/json",
        },
        body: jsonEncode(annotationData),
      );



      if (response.statusCode == 200) {
        log('INFO', "✅ Annotation saved successfully via Edge Function.");
        return true;
      } else {
        log('ERROR', "❌ Failed to insert annotation via Edge Function: ${response.body}");
        return false;
      }
    } catch (e) {
      log('ERROR', "❌ Error saving annotation via Edge Function: $e");
      return false;
    }
  }

  /// 📌 **이미지 Public URL 가져오기**
  Future<String> getPublicUrl(String imageStorageKey) async {
    try {
      log('INFO', "🌍 Fetching public URL for: $imageStorageKey");

      final publicUrl = _supabase.storage
          .from('work_room_annotations')
          .getPublicUrl(imageStorageKey);

      log('INFO', "✅ Public URL: $publicUrl");
      return publicUrl;
    } catch (e) {
      log('ERROR', "❌ Failed to get public URL for $imageStorageKey: $e");
      throw Exception("Failed to get public URL for $imageStorageKey.");
    }
  }
}


// ===== FILE: ./lib/features/document_annotation/data/document_annotation_model.dart =====

import 'package:flutter/painting.dart';
import 'package:json_annotation/json_annotation.dart';

part 'document_annotation_model.g.dart';

@JsonSerializable()
class DocumentAnnotationModel {
  final String id;
  final String? documentId; // Nullable
  final String parentFileStorageKey; // Required
  final String? workRoomId; // Nullable
  final String? annotationType;
  final int? pageNumber;
  final int? startPosition;
  final int? endPosition;
  final double? x1;
  final double? y1;
  final double? x2;
  final double? y2;
  final String? imageFileStorageKey;
  final bool isOcr; // Defaulted to false in fromJson
  final String? ocrText;
  final String? content; // Nullable
  final String createdBy; // Required
  final DateTime createdAt;
  final DateTime updatedAt;

  DocumentAnnotationModel({
    required this.id,
    required this.documentId,
    required this.parentFileStorageKey,
    this.workRoomId,
    this.annotationType,
    this.pageNumber,
    this.startPosition,
    this.endPosition,
    this.x1,
    this.y1,
    this.x2,
    this.y2,
    this.imageFileStorageKey,
    required this.isOcr,
    this.ocrText,
    this.content,
    required this.createdBy,
    required this.createdAt,
    required this.updatedAt,
  });

  factory DocumentAnnotationModel.fromJson(Map<String, dynamic> json) {
    print(json);
    if (json['id'] == null) throw Exception("Missing 'id' in annotation JSON");
    if (json['parent_file_storage_key'] == null) {
      throw Exception("Missing 'parentFileStorageKey' in annotation JSON");
    }

    return DocumentAnnotationModel(
      id: json['id'] as String,
      documentId: json['document_id'] as String?,
      parentFileStorageKey: json['parent_file_storage_key'] as String,
      workRoomId: json['work_room_id'] as String?,
      annotationType: json['annotation_type'] as String?,
      pageNumber: json['page_number'] as int?,
      startPosition: json['start_position'] as int?,
      endPosition: json['end_position'] as int?,
      x1: (json['x1'] as num?)?.toDouble(),
      y1: (json['y1'] as num?)?.toDouble(),
      x2: (json['x2'] as num?)?.toDouble(),
      y2: (json['y2'] as num?)?.toDouble(),
      imageFileStorageKey: json['image_file_storage_key'] as String?,
      isOcr: json['is_ocr'] as bool? ?? false,
      ocrText: json['ocr_text'] as String?,
      content: json['content'] as String?,
      createdBy: json['created_by'] as String? ?? 'Unknown',
      createdAt: DateTime.parse(json['created_at'] as String),
      updatedAt: DateTime.parse(json['updated_at'] as String),
    );
  }

  Map<String, dynamic> toJson() => _$DocumentAnnotationModelToJson(this);

  static Map<String, dynamic> rectToJson(Rect rect) {
    return {
      'x1': rect.left,
      'y1': rect.top,
      'x2': rect.right,
      'y2': rect.bottom,
    };
  }

  static Rect jsonToRect(Map<String, dynamic> json) {
    return Rect.fromLTRB(
      (json['x1'] as num?)?.toDouble() ?? 0.0,
      (json['y1'] as num?)?.toDouble() ?? 0.0,
      (json['x2'] as num?)?.toDouble() ?? 0.0,
      (json['y2'] as num?)?.toDouble() ?? 0.0,
    );
  }
}


// ===== FILE: ./lib/features/document_annotation/data/document_annotation_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'document_annotation_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

DocumentAnnotationModel _$DocumentAnnotationModelFromJson(
        Map<String, dynamic> json) =>
    DocumentAnnotationModel(
      id: json['id'] as String,
      documentId: json['documentId'] as String?,
      parentFileStorageKey: json['parentFileStorageKey'] as String,
      workRoomId: json['workRoomId'] as String?,
      annotationType: json['annotationType'] as String?,
      pageNumber: (json['pageNumber'] as num?)?.toInt(),
      startPosition: (json['startPosition'] as num?)?.toInt(),
      endPosition: (json['endPosition'] as num?)?.toInt(),
      x1: (json['x1'] as num?)?.toDouble(),
      y1: (json['y1'] as num?)?.toDouble(),
      x2: (json['x2'] as num?)?.toDouble(),
      y2: (json['y2'] as num?)?.toDouble(),
      imageFileStorageKey: json['imageFileStorageKey'] as String?,
      isOcr: json['isOcr'] as bool,
      ocrText: json['ocrText'] as String?,
      content: json['content'] as String?,
      createdBy: json['createdBy'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );

Map<String, dynamic> _$DocumentAnnotationModelToJson(
        DocumentAnnotationModel instance) =>
    <String, dynamic>{
      'id': instance.id,
      'documentId': instance.documentId,
      'parentFileStorageKey': instance.parentFileStorageKey,
      'workRoomId': instance.workRoomId,
      'annotationType': instance.annotationType,
      'pageNumber': instance.pageNumber,
      'startPosition': instance.startPosition,
      'endPosition': instance.endPosition,
      'x1': instance.x1,
      'y1': instance.y1,
      'x2': instance.x2,
      'y2': instance.y2,
      'imageFileStorageKey': instance.imageFileStorageKey,
      'isOcr': instance.isOcr,
      'ocrText': instance.ocrText,
      'content': instance.content,
      'createdBy': instance.createdBy,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
    };


// ===== FILE: ./lib/features/document_annotation/presentation/annotation_thread_screen.dart =====

import 'package:flutter/material.dart';

import 'package:legalfactfinder2025/features/document_annotation/data/document_annotation_model.dart';

class AnnotationThreadScreen extends StatelessWidget {
  final DocumentAnnotationModel annotation;
  final ScrollController scrollController;

  const AnnotationThreadScreen({
    Key? key,
    required this.annotation,
    required this.scrollController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Header
        Row(
          children: [
            IconButton(
              icon: const Icon(Icons.close),
              onPressed: () => Navigator.pop(context),
            ),
            const SizedBox(width: 8),
            const Text(
              "Annotation Thread",
              style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            ),
          ],
        ),
        const Divider(),
        // Parent annotation display
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: Text(
            annotation.content ?? 'No Content',
            style: const TextStyle(fontSize: 16),
          ),
        ),
        const Divider(),
        // Placeholder for thread messages
        Expanded(
          child: Center(
            child: Text(
              "Thread messages will be displayed here.",
              style: TextStyle(fontSize: 16, color: Colors.grey[600]),
            ),
          ),
        ),
        // Placeholder for input field
        Padding(
          padding: const EdgeInsets.all(8.0),
          child: TextField(
            decoration: InputDecoration(
              labelText: "Add a reply...",
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(12),
              ),
            ),
          ),
        ),
      ],
    );
  }
}


// ===== FILE: ./lib/features/document_annotation/presentation/annotation_manager.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/document_annotation/annotation_controller.dart';

Rect createDefaultAnnotationRect(BuildContext context) {
  final screenWidth = MediaQuery.of(context).size.width;
  final screenHeight = MediaQuery.of(context).size.height;
  return Rect.fromCenter(
    center: Offset(screenWidth / 2, screenHeight / 2),
    width: 200,
    height: 150,
  );
}

Future<void> saveAnnotationToController(
    AnnotationController annotationController,
    String workRoomId,
    String fileName,
    int page,
    Rect? rect,
    String text,
    VoidCallback onSuccess,
    ) async {
  if (rect != null) {
    bool success = await annotationController.saveAnnotation(
      workRoomId: workRoomId,
      fileName: fileName,
      page: page,
      rect: rect,
      text: text,
      imageBytes: null,
    );

    if (success) {
      onSuccess();
    }
  }
}


// ===== FILE: ./lib/features/document_annotation/presentation/widgets/annotation_display.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/document_annotation/data/document_annotation_model.dart';
import 'package:legalfactfinder2025/features/document_annotation/presentation/widgets/annotation_overlay.dart';

class AnnotationDisplay extends StatelessWidget {
  final List<DocumentAnnotationModel> annotations;
  final Rect? selectedRect;
  final bool isAnnotationMode;
  final VoidCallback toggleAnnotationMode;
  final Function(String) onSaveAnnotation;

  const AnnotationDisplay({
    Key? key,
    required this.annotations,
    required this.selectedRect,
    required this.isAnnotationMode,
    required this.toggleAnnotationMode,
    required this.onSaveAnnotation,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        for (var annotation in annotations)
          AnnotationOverlay(
            annotation: annotation,
            selectedRect: Rect.fromLTRB(
              annotation.x1 ?? 0.0,
              annotation.y1 ?? 0.0,
              annotation.x2 ?? 0.0,
              annotation.y2 ?? 0.0,
            ),
            isEditable: false,
            onUpdate: (_) {},
            onIconTap: () {},
          ),
      ],
    );
  }
}


// ===== FILE: ./lib/features/document_annotation/presentation/widgets/input_annotation_bottom_sheet.dart =====

import 'package:flutter/material.dart';

class InputAnnotationBottomSheet extends StatelessWidget {
  final Function(String) onSave;

  const InputAnnotationBottomSheet({
    Key? key,
    required this.onSave,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    String annotationText = "";

    return Padding(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
        top: 16,
        left: 16,
        right: 16,
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          TextField(
            decoration: const InputDecoration(
              labelText: "Enter annotation",
              border: OutlineInputBorder(),
            ),
            minLines: 3,
            maxLines: 8,
            onChanged: (value) => annotationText = value,
          ),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: () {
              if (annotationText.isNotEmpty) {
                onSave(annotationText);
                Navigator.pop(context);
              }
            },
            child: const Text("Save"),
          ),
          const SizedBox(height: 16),
        ],
      ),
    );
  }
}


// ===== FILE: ./lib/features/document_annotation/presentation/widgets/annotation_overlay.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/document_annotation/data/document_annotation_model.dart';

class AnnotationOverlay extends StatefulWidget {
  final DocumentAnnotationModel annotation;
  final Rect selectedRect;
  final Function(Rect) onUpdate;
  final VoidCallback onIconTap;
  final bool isEditable;

  const AnnotationOverlay({
    Key? key,
    required this.annotation,
    required this.selectedRect,
    required this.onUpdate,
    required this.onIconTap,
    this.isEditable = false,
  }) : super(key: key);

  @override
  _AnnotationOverlayState createState() => _AnnotationOverlayState();
}

class _AnnotationOverlayState extends State<AnnotationOverlay> {
  late Rect _rect;

  @override
  void initState() {
    super.initState();
    _rect = widget.selectedRect;
  }

  void _updateCorner(Offset delta, Alignment alignment) {
    if (!widget.isEditable) return;

    setState(() {
      double left = _rect.left;
      double top = _rect.top;
      double right = _rect.right;
      double bottom = _rect.bottom;

      if (alignment == Alignment.topLeft) {
        left += delta.dx;
        top += delta.dy;
      } else if (alignment == Alignment.topRight) {
        right += delta.dx;
        top += delta.dy;
      } else if (alignment == Alignment.bottomLeft) {
        left += delta.dx;
        bottom += delta.dy;
      } else if (alignment == Alignment.bottomRight) {
        right += delta.dx;
        bottom += delta.dy;
      }

      _rect = Rect.fromLTRB(
        left < right ? left : right,
        top < bottom ? top : bottom,
        left < right ? right : left,
        top < bottom ? bottom : top,
      );
    });

    widget.onUpdate(_rect);
  }

  Widget _buildCornerMarker(Alignment alignment) {
    return Positioned(
      left: alignment == Alignment.topLeft || alignment == Alignment.bottomLeft
          ? _rect.left - 6
          : _rect.right - 6,
      top: alignment == Alignment.topLeft || alignment == Alignment.topRight
          ? _rect.top - 6
          : _rect.bottom - 6,
      child: GestureDetector(
        onPanUpdate: (details) => _updateCorner(details.delta, alignment),
        child: Container(
          width: 12,
          height: 12,
          decoration: BoxDecoration(
            color: Colors.white,
            border: Border.all(color: Colors.red, width: 2),
            shape: BoxShape.circle,
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        Positioned.fromRect(
          rect: _rect,
          child: GestureDetector(
            onPanUpdate: widget.isEditable
                ? (details) => setState(() {
              _rect = _rect.shift(details.delta);
              widget.onUpdate(_rect);
            })
                : null,
            child: Container(
              decoration: BoxDecoration(
                border: Border.all(color: Colors.red, width: 2),
                color: Colors.red.withOpacity(0.2),
              ),
            ),
          ),
        ),
        if (widget.isEditable) ...[
          _buildCornerMarker(Alignment.topLeft),
          _buildCornerMarker(Alignment.topRight),
          _buildCornerMarker(Alignment.bottomLeft),
          _buildCornerMarker(Alignment.bottomRight),
        ],
        if (!widget.isEditable)
          Positioned(
            left: _rect.right - 16,
            top: _rect.top - 16,
            child: GestureDetector(
              onTap: widget.onIconTap,
              child: Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  color: Colors.blue,
                  shape: BoxShape.circle,
                  border: Border.all(color: Colors.white, width: 2),
                ),
                child: const Icon(Icons.info, color: Colors.white, size: 16),
              ),
            ),
          ),
      ],
    );
  }
}


// ===== FILE: ./lib/features/document_annotation/presentation/widgets/corner_marker_widget.dart =====

import 'package:flutter/material.dart';

class CornerMarkerWidget extends StatelessWidget {
  final Offset position;
  final Alignment alignment;
  final Function(Offset delta) onDrag;

  const CornerMarkerWidget({
    Key? key,
    required this.position,
    required this.alignment,
    required this.onDrag,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: alignment,
      child: GestureDetector(
        onPanUpdate: (details) => onDrag(details.delta),
        child: Container(
          width: 10,
          height: 10,
          decoration: BoxDecoration(
            color: Colors.white,
            shape: BoxShape.circle,
            border: Border.all(color: Colors.red),
          ),
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/document_annotation/presentation/widgets/annotation_dialog.dart =====

import 'package:flutter/material.dart';

class AnnotationDialog extends StatelessWidget {
  final Function(String) onSave;

  const AnnotationDialog({Key? key, required this.onSave}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final TextEditingController controller = TextEditingController();

    return AlertDialog(
      title: const Text("Add Comment"),
      content: TextField(
        controller: controller,
        keyboardType: TextInputType.multiline,
        maxLines: 3,
        decoration: const InputDecoration(hintText: "Enter your comment"),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text("Cancel"),
        ),
        TextButton(
          onPressed: () {
            onSave(controller.text);
            Navigator.of(context).pop();
          },
          child: const Text("Save"),
        ),
      ],
    );
  }
}


// ===== FILE: ./lib/features/audio_record/presentation/audio_recorder_page.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_sound/public/flutter_sound_recorder.dart';
import 'dart:io';
import 'dart:async';
import 'package:permission_handler/permission_handler.dart';
import 'package:speech_to_text/speech_to_text.dart' as stt;
import 'package:supabase_flutter/supabase_flutter.dart';

class AudioRecorderPage extends StatefulWidget {
  @override
  _AudioRecorderPageState createState() => _AudioRecorderPageState();
}

class _AudioRecorderPageState extends State<AudioRecorderPage> {
  final FlutterSoundRecorder _recorder = FlutterSoundRecorder();
  final stt.SpeechToText _speechToText = stt.SpeechToText();
  bool _isRecording = false;
  bool _isPaused = false;
  double _decibels = 0.0;
  String? _recordedFilePath;
  Timer? _timer;
  int _elapsedSeconds = 0;
  int _speakerCount = 2;
  String _transcription = '';
  final supabase = Supabase.instance.client;

  @override
  void initState() {
    super.initState();
    _askSpeakerCount().then((_) => _initRecorder());
  }

  @override
  void dispose() {
    _recorder.closeRecorder();
    _timer?.cancel();
    super.dispose();
  }

  Future<void> _askSpeakerCount() async {
    final count = await showDialog<int>(
      context: context,
      builder: (context) {
        int tempCount = _speakerCount;
        return AlertDialog(
          title: const Text('대화자 수 설정'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Text('대화자 수를 선택하세요:'),
              StatefulBuilder(
                builder: (context, setState) {
                  return DropdownButton<int>(
                    value: tempCount,
                    items: List.generate(10, (index) => index + 1).map((e) {
                      return DropdownMenuItem<int>(
                        value: e,
                        child: Text('$e명'),
                      );
                    }).toList(),
                    onChanged: (value) {
                      setState(() {
                        tempCount = value ?? 2;
                      });
                    },
                  );
                },
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context, tempCount),
              child: const Text('확인'),
            ),
          ],
        );
      },
    );

    if (count != null) {
      setState(() {
        _speakerCount = count;
      });
    }
  }

  Future<void> _initRecorder() async {
    final status = await Permission.microphone.request();
    if (status != PermissionStatus.granted) {
      throw RecordingPermissionException('Microphone permission not granted');
    }
    await _recorder.openRecorder();
    _recorder.setSubscriptionDuration(const Duration(milliseconds: 200));
    _recorder.onProgress?.listen((event) {
      if (_recorder.isRecording) {
        setState(() {
          _decibels = event.decibels ?? 0.0;
        });
      }
    });
  }

  void _startTimer() {
    _timer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (_isRecording && !_isPaused) {
        setState(() {
          _elapsedSeconds++;
        });
      }
    });
  }

  void _stopTimer() {
    _timer?.cancel();
  }

  Future<void> _pauseRecording() async {
    await _recorder.pauseRecorder();
    setState(() {
      _isPaused = true;
    });
  }

  Future<void> _resumeRecording() async {
    await _recorder.resumeRecorder();
    setState(() {
      _isPaused = false;
    });
  }

  Future<void> _startListening() async {
    bool available = await _speechToText.initialize();
    if (available) {
      _speechToText.listen(
        onResult: (result) {
          setState(() {
            _transcription += result.recognizedWords + '\n';
          });
        },
        localeId: 'ko-KR',
      );
    }
  }

  Future<void> _stopListening() async {
    await _speechToText.stop();
  }

  Future<void> _uploadToSupabase() async {
    try {
      final audioFileName = 'audio_${DateTime.now().millisecondsSinceEpoch}.aac';
      final audioPath = await supabase.storage.from('recordings').upload(audioFileName, File(_recordedFilePath!));
      final transcriptionFileName = 'transcription_${DateTime.now().millisecondsSinceEpoch}.txt';
      final transcriptionFile = File('${Directory.systemTemp.path}/$transcriptionFileName')
        ..writeAsStringSync(_transcription);
      await supabase.storage.from('transcriptions').upload(transcriptionFileName, transcriptionFile);
      print('Uploaded audio: $audioPath');
    } catch (e) {
      print('Error uploading files: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Audio Recorder with Transcription')),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Stack(
              alignment: Alignment.center,
              children: [
                AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  width: 200,
                  height: 200,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: _isRecording
                        ? Colors.red.withOpacity((_decibels / 120).clamp(0.2, 1.0))
                        : Colors.grey,
                  ),
                ),
                Icon(
                  Icons.mic,
                  size: 80,
                  color: _isRecording ? Colors.white : Colors.grey[400],
                ),
              ],
            ),
            const SizedBox(height: 20),
            Text(
              _formatTime(_elapsedSeconds),
              style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 20),
            if (_transcription.isNotEmpty)
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: Text(
                  '실시간 자막:\n$_transcription',
                  style: const TextStyle(fontSize: 16),
                ),
              ),
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconButton(
                  icon: const Icon(Icons.fiber_manual_record, color: Colors.red),
                  iconSize: 50,
                  onPressed: (_isRecording || _isPaused) ? null : () async {
                    _recordedFilePath = '${Directory.systemTemp.path}/recording.aac';
                    await _recorder.startRecorder(toFile: _recordedFilePath);
                    await _startListening();
                    setState(() {
                      _isRecording = true;
                      _isPaused = false;
                      _elapsedSeconds = 0;
                    });
                    _startTimer();
                  },
                ),
                IconButton(
                  icon: Icon(Icons.pause, color: _isPaused ? Colors.deepOrange : Colors.orange),
                  iconSize: 50,
                  onPressed: _isRecording && !_isPaused ? _pauseRecording : (_isPaused ? _resumeRecording : null),
                ),
                IconButton(
                  icon: const Icon(Icons.stop, color: Colors.black),
                  iconSize: 50,
                  onPressed: _isRecording || _isPaused ? () async {
                    await _recorder.stopRecorder();
                    await _stopListening();
                    await _uploadToSupabase();
                    setState(() {
                      _isRecording = false;
                      _isPaused = false;
                    });
                    _stopTimer();
                  } : null,
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
  String _formatTime(int seconds) {
    final minutes = seconds ~/ 60;
    final remainingSeconds = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${remainingSeconds.toString().padLeft(2, '0')}';
  }

}


// ===== FILE: ./lib/features/agreement/presentation/term_of_service_page.dart =====

import 'package:flutter/material.dart';

class TermsOfServicePage extends StatelessWidget {
  const TermsOfServicePage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Terms of Service")),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: const [
              Text(
                "Legal FactFinder Terms of Service",
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
              ),
              SizedBox(height: 10),
              Text(
                "By using Legal FactFinder, you agree to abide by the following terms and conditions...",
              ),
              // 약관 내용 추가...
            ],
          ),
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/agreement/presentation/privacy_polity_page.dart =====

import 'package:flutter/material.dart';

class PrivacyPolicyPage extends StatelessWidget {
  const PrivacyPolicyPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text("Privacy Policy")),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: const [
              Text(
                "Legal FactFinder Privacy Policy",
                style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
              ),
              SizedBox(height: 10),
              Text(
                "Legal FactFinder is committed to protecting your privacy...",
              ),
              // 개인정보 보호 정책 내용 추가...
            ],
          ),
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/profile/profile_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/profile/data/profile_model.dart';

class ProfileController extends GetxController {
  // Profile 상태 관리
  var profile = Rxn<Profile>(); // 로드된 Profile 데이터
  var isLoading = false.obs;    // 로딩 상태
  var errorMessage = ''.obs;    // 에러 메시지 (필요한 경우)

  Future<void> fetchProfileById(String userId) async {
    // Fetch and update profile data based on userId
  }

  // Profile 데이터 로드
  Future<void> fetchProfile() async {
    isLoading.value = true; // 로딩 시작
    errorMessage.value = ''; // 기존 에러 초기화

    try {
      // 여기에 API 호출 또는 데이터 로드 로직 추가
      // 예: 2초 대기 후 샘플 데이터 로드
      await Future.delayed(const Duration(seconds: 2));

      profile.value = Profile(
        user: User(
          id: "01ba12d0-da6a-45e0-8535-6d2e49a4f96e",
          username: "user_006",
          email: "user006@example.com",
          isLawyer: true,
          profilePictureUrl: "https://example.com/profiles/6.png",
          bio: "Hello, I am user 006!",
          country: "South Korea",
          status: "offline",
          createdAt: DateTime.parse("2025-01-21T07:34:22.62714+00:00"),
          updatedAt: DateTime.parse("2025-01-21T07:34:22.62714+00:00"),
        ),
        lawyerProfile: LawyerProfile(
          lawyerProfileId: "01ba12d0-da6a-45e0-8535-6d2e49a4f96e",
          practiceAreas: null,
          education: null,
          lawFirm: "Firm A",
          biography: "Experienced corporate lawyer",
          certifications: null,
          languages: null,
          isVerified: true,
        ),
        lawyerLicenses: [
          LawyerLicense(
            licenseId: "aca7865a-8915-4f26-ab84-73745bce3446",
            licenseCountry: "USA",
            licenseState: "California",
            licenseYear: 2020,
            licenseTitle: "Senior Lawyer",
            createdAt: DateTime.parse("2023-01-01T10:00:00+00:00"),
            updatedAt: DateTime.parse("2023-01-10T15:00:00+00:00"),
          ),
        ],
      );
    } catch (e) {
      errorMessage.value = 'Failed to load profile'; // 에러 메시지 업데이트
    } finally {
      isLoading.value = false; // 로딩 종료
    }
  }

  @override
  void onInit() {
    super.onInit();
    fetchProfile(); // 컨트롤러 초기화 시 데이터 로드
  }
}


// ===== FILE: ./lib/features/profile/data/profile_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'profile_model.g.dart';

@JsonSerializable()
class Profile {
  final User user;
  final LawyerProfile? lawyerProfile;
  final List<LawyerLicense>? lawyerLicenses;

  Profile({
    required this.user,
    this.lawyerProfile,
    this.lawyerLicenses,
  });

  factory Profile.fromJson(Map<String, dynamic> json) => _$ProfileFromJson(json);
  Map<String, dynamic> toJson() => _$ProfileToJson(this);
}

@JsonSerializable()
class User {
  final String id;
  final String username;
  final String email;
  final bool isLawyer;
  final String profilePictureUrl;
  final String bio;
  final String country;
  final String status;
  final DateTime createdAt;
  final DateTime updatedAt;

  User({
    required this.id,
    required this.username,
    required this.email,
    required this.isLawyer,
    required this.profilePictureUrl,
    required this.bio,
    required this.country,
    required this.status,
    required this.createdAt,
    required this.updatedAt,
  });

  factory User.fromJson(Map<String, dynamic> json) => _$UserFromJson(json);
  Map<String, dynamic> toJson() => _$UserToJson(this);
}

@JsonSerializable()
class LawyerProfile {
  final String lawyerProfileId;
  final String? practiceAreas;
  final String? education;
  final String lawFirm;
  final String biography;
  final String? certifications;
  final String? languages;
  final bool isVerified;

  LawyerProfile({
    required this.lawyerProfileId,
    this.practiceAreas,
    this.education,
    required this.lawFirm,
    required this.biography,
    this.certifications,
    this.languages,
    required this.isVerified,
  });

  factory LawyerProfile.fromJson(Map<String, dynamic> json) => _$LawyerProfileFromJson(json);
  Map<String, dynamic> toJson() => _$LawyerProfileToJson(this);
}

@JsonSerializable()
class LawyerLicense {
  final String licenseId;
  final String licenseCountry;
  final String licenseState;
  final int licenseYear;
  final String licenseTitle;
  final DateTime createdAt;
  final DateTime updatedAt;

  LawyerLicense({
    required this.licenseId,
    required this.licenseCountry,
    required this.licenseState,
    required this.licenseYear,
    required this.licenseTitle,
    required this.createdAt,
    required this.updatedAt,
  });

  factory LawyerLicense.fromJson(Map<String, dynamic> json) => _$LawyerLicenseFromJson(json);
  Map<String, dynamic> toJson() => _$LawyerLicenseToJson(this);
}
//flutter pub run build_runner build

// ===== FILE: ./lib/features/profile/data/profile_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'profile_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

Profile _$ProfileFromJson(Map<String, dynamic> json) => Profile(
      user: User.fromJson(json['user'] as Map<String, dynamic>),
      lawyerProfile: json['lawyerProfile'] == null
          ? null
          : LawyerProfile.fromJson(
              json['lawyerProfile'] as Map<String, dynamic>),
      lawyerLicenses: (json['lawyerLicenses'] as List<dynamic>?)
          ?.map((e) => LawyerLicense.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$ProfileToJson(Profile instance) => <String, dynamic>{
      'user': instance.user,
      'lawyerProfile': instance.lawyerProfile,
      'lawyerLicenses': instance.lawyerLicenses,
    };

User _$UserFromJson(Map<String, dynamic> json) => User(
      id: json['id'] as String,
      username: json['username'] as String,
      email: json['email'] as String,
      isLawyer: json['isLawyer'] as bool,
      profilePictureUrl: json['profilePictureUrl'] as String,
      bio: json['bio'] as String,
      country: json['country'] as String,
      status: json['status'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );

Map<String, dynamic> _$UserToJson(User instance) => <String, dynamic>{
      'id': instance.id,
      'username': instance.username,
      'email': instance.email,
      'isLawyer': instance.isLawyer,
      'profilePictureUrl': instance.profilePictureUrl,
      'bio': instance.bio,
      'country': instance.country,
      'status': instance.status,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
    };

LawyerProfile _$LawyerProfileFromJson(Map<String, dynamic> json) =>
    LawyerProfile(
      lawyerProfileId: json['lawyerProfileId'] as String,
      practiceAreas: json['practiceAreas'] as String?,
      education: json['education'] as String?,
      lawFirm: json['lawFirm'] as String,
      biography: json['biography'] as String,
      certifications: json['certifications'] as String?,
      languages: json['languages'] as String?,
      isVerified: json['isVerified'] as bool,
    );

Map<String, dynamic> _$LawyerProfileToJson(LawyerProfile instance) =>
    <String, dynamic>{
      'lawyerProfileId': instance.lawyerProfileId,
      'practiceAreas': instance.practiceAreas,
      'education': instance.education,
      'lawFirm': instance.lawFirm,
      'biography': instance.biography,
      'certifications': instance.certifications,
      'languages': instance.languages,
      'isVerified': instance.isVerified,
    };

LawyerLicense _$LawyerLicenseFromJson(Map<String, dynamic> json) =>
    LawyerLicense(
      licenseId: json['licenseId'] as String,
      licenseCountry: json['licenseCountry'] as String,
      licenseState: json['licenseState'] as String,
      licenseYear: (json['licenseYear'] as num).toInt(),
      licenseTitle: json['licenseTitle'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );

Map<String, dynamic> _$LawyerLicenseToJson(LawyerLicense instance) =>
    <String, dynamic>{
      'licenseId': instance.licenseId,
      'licenseCountry': instance.licenseCountry,
      'licenseState': instance.licenseState,
      'licenseYear': instance.licenseYear,
      'licenseTitle': instance.licenseTitle,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
    };


// ===== FILE: ./lib/features/profile/data/profile_repository.dart =====



// ===== FILE: ./lib/features/profile/domain/update_profile_usecase.dart =====



// ===== FILE: ./lib/features/profile/domain/fetch_profile_usecase.dart =====



// ===== FILE: ./lib/features/profile/domain/delete_profile_usecase.dart =====



// ===== FILE: ./lib/features/profile/presentation/edit_profile_page.dart =====



// ===== FILE: ./lib/features/profile/presentation/widgets/licenses_list.dart =====



// ===== FILE: ./lib/features/profile/presentation/widgets/profile_action_buttons.dart =====



// ===== FILE: ./lib/features/profile/presentation/widgets/profile_header.dart =====



// ===== FILE: ./lib/features/profile/presentation/widgets/lawyer_info_section.dart =====



// ===== FILE: ./lib/features/profile/presentation/profile_page.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/profile/profile_controller.dart';

class ProfilePage extends StatelessWidget {
  final ProfileController profileController = Get.put(ProfileController());

  @override
  Widget build(BuildContext context) {
    final userId = Get.arguments; // Retrieve the passed userId
    profileController.fetchProfileById(userId); // Fetch profile by userId

    return Scaffold(
      appBar: AppBar(
        title: Text('Profile'),
      ),
      body: Obx(() {
        if (profileController.isLoading.value) {
          return Center(child: CircularProgressIndicator());
        }

        if (profileController.errorMessage.value.isNotEmpty) {
          return Center(child: Text(profileController.errorMessage.value));
        }

        final profile = profileController.profile.value;
        if (profile == null) {
          return Center(child: Text('Profile not found'));
        }

        return Column(
          children: [
            Expanded(
              child: SingleChildScrollView(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    SizedBox(height: 20),
                    CircleAvatar(
                      radius: 60,
                      backgroundImage: NetworkImage(profile.user.profilePictureUrl),
                    ),
                    SizedBox(height: 20),
                    Text(
                      profile.user.username,
                      style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
                    ),
                    SizedBox(height: 10),
                    Text(profile.user.email, style: TextStyle(fontSize: 16, color: Colors.grey)),
                    SizedBox(height: 10),
                    Text(profile.user.bio, textAlign: TextAlign.center, style: TextStyle(fontSize: 16)),
                    SizedBox(height: 20),
                    if (profile.user.isLawyer)
                      Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Divider(),
                          Padding(
                            padding: const EdgeInsets.symmetric(horizontal: 20.0),
                            child: Text('Lawyer Details', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                          ),
                          ListTile(
                            title: Text('Law Firm'),
                            subtitle: Text(profile.lawyerProfile?.lawFirm ?? 'N/A'),
                          ),
                          ListTile(
                            title: Text('Biography'),
                            subtitle: Text(profile.lawyerProfile?.biography ?? 'N/A'),
                          ),
                          ListTile(
                            title: Text('Verified'),
                            subtitle: Text(profile.lawyerProfile?.isVerified == true ? 'Yes' : 'No'),
                          ),
                          Divider(),
                          Padding(
                            padding: const EdgeInsets.symmetric(horizontal: 20.0),
                            child: Text('Licenses', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                          ),
                          ...?profile.lawyerLicenses?.map((license) => ListTile(
                            title: Text(license.licenseTitle),
                            subtitle: Text('${license.licenseCountry}, ${license.licenseState} (${license.licenseYear})'),
                          )),
                        ],
                      ),
                    SizedBox(height: 40),
                  ],
                ),
              ),
            ),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 10.0),
              color: Colors.white,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: [
                  ElevatedButton.icon(
                    onPressed: () {
                      // 채팅하기 로직
                    },
                    icon: Icon(Icons.chat),
                    label: Text('Chat'),
                    style: ElevatedButton.styleFrom(minimumSize: Size(140, 50)),
                  ),
                  ElevatedButton.icon(
                    onPressed: () {
                      // 전화걸기 로직
                    },
                    icon: Icon(Icons.call),
                    label: Text('Call'),
                    style: ElevatedButton.styleFrom(minimumSize: Size(140, 50)),
                  ),
                ],
              ),
            ),
          ],
        );
      }),
    );
  }
}


// ===== FILE: ./lib/features/files/file_list_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/files/data/file_model.dart';
import 'package:legalfactfinder2025/features/files/data/file_data_repository.dart';

class FileListController extends GetxController {
  final FileDataRepository repository = FileDataRepository();

  var files = <FileData>[].obs;
  var isLoading = false.obs;
  var errorMessage = ''.obs;

  // ✅ 파일 목록 가져오기
  Future<void> fetchFiles(String workRoomId) async {
    final startTime = DateTime.now();
    print("🔄 [FileListController] Fetching files for WorkRoom '$workRoomId' at $startTime");

    isLoading.value = true;
    errorMessage.value = '';

    try {
      files.value = await repository.fetchFiles(workRoomId);
      print("✅ [FileListController] Successfully fetched ${files.length} files for WorkRoom '$workRoomId'");
    } catch (e, stacktrace) {
      errorMessage.value = 'Failed to load files: ${e.toString()}';
      print("❌ [FileListController] Error fetching files: $e");
      print("🔍 Stacktrace: $stacktrace");
    } finally {
      isLoading.value = false;
      final endTime = DateTime.now();
      final duration = endTime.difference(startTime);
      print("⏳ [FileListController] fetchFiles completed in ${duration.inMilliseconds}ms");
    }
  }

  // ✅ 파일 업로드
  Future<void> uploadFile(String path, String fileName, String description, String workRoomId, String uploaderId) async {
    final startTime = DateTime.now();
    print("🔄 [FileListController] Uploading file '$fileName' to WorkRoom '$workRoomId' at $startTime");

    isLoading.value = true;

    try {
      await repository.uploadFile(
        path: path,
        fileName: fileName,
        description: description,
        workRoomId: workRoomId,
        uploaderId: uploaderId,
      );

      print("✅ [FileListController] File '$fileName' uploaded successfully!");
      await fetchFiles(workRoomId); // ✅ 업로드 후 리스트 갱신
    } catch (e, stacktrace) {
      errorMessage.value = 'Failed to upload file: ${e.toString()}';
      print("❌ [FileListController] Error uploading file: $e");
      print("🔍 Stacktrace: $stacktrace");
    } finally {
      isLoading.value = false;
      final endTime = DateTime.now();
      final duration = endTime.difference(startTime);
      print("⏳ [FileListController] uploadFile completed in ${duration.inMilliseconds}ms");
    }
  }

  // ✅ 파일 다운로드
  Future<void> downloadFile(String fileName, String savePath) async {
    final startTime = DateTime.now();
    print("🔄 [FileListController] Downloading file '$fileName' to '$savePath' at $startTime");

    isLoading.value = true;

    try {
      await repository.downloadFile(fileName, savePath);
      print("✅ [FileListController] File '$fileName' downloaded successfully to '$savePath'");
    } catch (e, stacktrace) {
      errorMessage.value = 'Failed to download file: ${e.toString()}';
      print("❌ [FileListController] Error downloading file: $e");
      print("🔍 Stacktrace: $stacktrace");
    } finally {
      isLoading.value = false;
      final endTime = DateTime.now();
      final duration = endTime.difference(startTime);
      print("⏳ [FileListController] downloadFile completed in ${duration.inMilliseconds}ms");
    }
  }
}


// ===== FILE: ./lib/features/files/file_view_controller.dart =====

import 'package:get/get.dart';
import 'dart:io';

import 'package:legalfactfinder2025/features/files/data/file_repository.dart';

class FileViewController extends GetxController {
  final FileRepository fileRepository;

  FileViewController(this.fileRepository);

  Rx<File?> file = Rx<File?>(null);
  RxBool isLoading = false.obs;
  RxString errorMessage = ''.obs;

  Future<void> loadFile(String bucketName, String filePath, String fileName) async {
    try {
      isLoading.value = true;
      final downloadedFile = await fileRepository.downloadFile(
        bucketName: bucketName,
        filePath: filePath,
        fileName: fileName,
      );

      if (downloadedFile == null) {
        errorMessage.value = "Failed to load file.";
      } else {
        file.value = downloadedFile;
      }
    } catch (e) {
      errorMessage.value = "An error occurred: $e";
    } finally {
      isLoading.value = false;
    }
  }
}


// ===== FILE: ./lib/features/files/data/file_repository.dart =====

import 'dart:io';
import 'dart:typed_data';
import 'package:path_provider/path_provider.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class FileRepository {
  Future<File?> downloadFile({
    required String bucketName,
    required String filePath,
    required String fileName,
  }) async {
    try {
      print("Downloading file from: $bucketName/$filePath");

      // Download file from Supabase Storage
      final Uint8List response = await Supabase.instance.client.storage
          .from(bucketName)
          .download(filePath);

      // Save file locally
      final directory = await getApplicationDocumentsDirectory();
      final localPath = '${directory.path}/$fileName';
      final file = File(localPath);
      await file.writeAsBytes(response);

      print("File saved locally: $localPath");
      return file;
    } catch (e) {
      print("Error downloading file: $e");
      return null;
    }
  }
}


// ===== FILE: ./lib/features/files/data/file_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'file_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

FileData _$FileDataFromJson(Map<String, dynamic> json) => FileData(
      id: json['id'] as String,
      storageKey: json['storageKey'] as String,
      fileName: json['fileName'] as String,
      fileType: json['fileType'] as String,
      fileSize: (json['fileSize'] as num).toInt(),
      uploadedAt: DateTime.parse(json['uploadedAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      workRoomId: json['workRoomId'] as String,
      uploaderId: json['uploaderId'] as String,
      description: json['description'] as String?,
      isDeleted: json['isDeleted'] as bool,
      deletedAt: json['deletedAt'] == null
          ? null
          : DateTime.parse(json['deletedAt'] as String),
    );

Map<String, dynamic> _$FileDataToJson(FileData instance) => <String, dynamic>{
      'id': instance.id,
      'storageKey': instance.storageKey,
      'fileName': instance.fileName,
      'fileType': instance.fileType,
      'fileSize': instance.fileSize,
      'uploadedAt': instance.uploadedAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
      'workRoomId': instance.workRoomId,
      'uploaderId': instance.uploaderId,
      'description': instance.description,
      'isDeleted': instance.isDeleted,
      'deletedAt': instance.deletedAt?.toIso8601String(),
    };


// ===== FILE: ./lib/features/files/data/file_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'file_model.g.dart';

@JsonSerializable()
class FileData {
  final String id;
  final String storageKey;
  final String fileName;
  final String fileType;
  final int fileSize;
  final DateTime uploadedAt;
  final DateTime updatedAt;
  final String workRoomId;
  final String uploaderId;
  final String? description;
  final bool isDeleted;
  final DateTime? deletedAt;

  FileData({
    required this.id,
    required this.storageKey,
    required this.fileName,
    required this.fileType,
    required this.fileSize,
    required this.uploadedAt,
    required this.updatedAt,
    required this.workRoomId,
    required this.uploaderId,
    this.description,
    required this.isDeleted,
    this.deletedAt,
  });

  factory FileData.fromJson(Map<String, dynamic> json) => _$FileDataFromJson(json);

  Map<String, dynamic> toJson() => _$FileDataToJson(this);
}
//flutter pub run build_runner build

// ===== FILE: ./lib/features/files/data/file_data_repository.dart =====

import 'dart:io';

import 'package:legalfactfinder2025/constants.dart';
import 'package:legalfactfinder2025/core/utils/formatters.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import 'file_model.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:uuid/uuid.dart';

class FileDataRepository {
  final supabase = Supabase.instance.client;

  Future<List<FileData>> fetchFiles(String workRoomId) async {
    final url = Uri.parse('$baseUrl/functions/v1/get_files_by_work_room_id');

    try {
      print(
          "🔵 [REQUEST] Fetching files for WorkRoom ID: $workRoomId from $url");

      // Call the Edge Function
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $jwtToken',
        },
        body: jsonEncode({'work_room_id': workRoomId}),
      );

      print("🟢 [RESPONSE] Status Code: ${response.statusCode}");
      print("🟢 Raw Body: ${response.body}");

      if (response.statusCode == 200) {
        final decodedResponse = utf8.decode(response.bodyBytes);
        final responseData = jsonDecode(decodedResponse);

        print("🔹 Parsed JSON: $responseData");

        // Ensure the response contains the 'files' key
        if (responseData is! Map<String, dynamic> ||
            !responseData.containsKey('files')) {
          throw Exception("Unexpected response format: Missing 'files' key.");
        }

        final filesList = responseData['files'] as List<dynamic>;

        // Map the files list to FileData objects
        return filesList.map((json) {
          print("Processing JSON object: $json");
          return FileData(
            id: json['id'] as String? ?? '',
            storageKey: json['file_url'] as String? ?? '',
            fileName: json['file_name'] as String? ?? 'Unknown File',
            fileType: json['file_type'] as String? ?? 'unknown',
            fileSize: json['file_size'] as int? ?? 0,
            uploadedAt:
                DateTime.tryParse(json['uploaded_at'] as String? ?? '') ??
                    DateTime.now(),
            updatedAt: DateTime.tryParse(json['updated_at'] as String? ?? '') ??
                DateTime.now(),
            workRoomId: workRoomId,
            uploaderId: json['uploader_id'] as String? ?? '',
            description: json['description'] as String? ?? 'No description',
            isDeleted: json['is_deleted'] as bool? ?? false,
            deletedAt: json['deleted_at'] != null
                ? DateTime.tryParse(json['deleted_at'] as String)
                : null,
          );
        }).toList();
      } else {
        throw Exception("Failed to fetch files: ${response.body}");
      }
    } catch (e) {
      print("🚨 [EXCEPTION] Error fetching files");
      print("🔴 Exception: $e");
      throw Exception("Error fetching files: $e");
    }
  }

  // Upload file to Supabase Storage and save metadata to the database
  Future<void> uploadFile({
    required String path,
    required String fileName,
    required String description,
    required String workRoomId,
    required String uploaderId,
  }) async {
    try {
      final file = File(path);

      final timestampedFileName = generateTimestampedFileName(fileName);
      // Upload file to Supabase Storage
      final storageResponse = await supabase.storage
          .from('work_room_files')
          .upload(workRoomId + '/' + timestampedFileName, file);
      if (storageResponse.isEmpty) {
        throw Exception('Failed to upload file.');
      }
    } catch (e) {
      throw Exception('Error uploading file: $e');
    }
  }

  // Download file from Supabase Storage
  Future<void> downloadFile(String fileName, String savePath) async {
    try {
      final response =
          await supabase.storage.from('work_room_files').download(fileName);
      if (response.isEmpty) {
        throw Exception('Failed to download file.');
      }

      final file = File(savePath);
      await file.writeAsBytes(response);
    } catch (e) {
      throw Exception('Error downloading file: $e');
    }
  }
}


// ===== FILE: ./lib/features/files/domain/download_file_usecase.dart =====



// ===== FILE: ./lib/features/files/domain/upload_file_usecase.dart =====



// ===== FILE: ./lib/features/files/domain/delete_file_usecase.dart =====



// ===== FILE: ./lib/features/files/domain/update_file_usecase.dart =====



// ===== FILE: ./lib/features/files/file_data_controller.dart =====



// ===== FILE: ./lib/features/files/presentation/image_file_view_screen.dart =====

import 'dart:async';
import 'dart:io';
import 'dart:typed_data';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/document_annotation/annotation_controller.dart';
import 'package:legalfactfinder2025/features/document_annotation/data/annotation_repository.dart';
import 'package:legalfactfinder2025/features/files/file_view_controller.dart';
import 'dart:ui' as ui;
import 'package:image/image.dart' as img;

class ImageFileViewScreen extends StatefulWidget {
  final String workRoomId;
  final String fileName;

  const ImageFileViewScreen({
    Key? key,
    required this.workRoomId,
    required this.fileName,
  }) : super(key: key);

  @override
  _ImageFileViewScreenState createState() => _ImageFileViewScreenState();
}

class _ImageFileViewScreenState extends State<ImageFileViewScreen>
    with AutomaticKeepAliveClientMixin {
  final GlobalKey _imageViewKey = GlobalKey();

  @override
  bool get wantKeepAlive => true;

  bool _isAnnotationMode = false;
  Rect? _selectedRect;
  ui.Image? _croppedImage;

   final AnnotationController _annotationController = Get.put(AnnotationController());

  @override
  void initState() {
    super.initState();
    final FileViewController controller = Get.find<FileViewController>();
    controller.loadFile(
      'work_room_files',
      '${widget.workRoomId}/${widget.fileName}',
      widget.fileName,
    );
  }

  void _startDrawing(Offset startPosition) {
    setState(() {
      _selectedRect = Rect.fromLTWH(startPosition.dx, startPosition.dy, 0, 0);
    });
  }

  void _updateDrawing(Offset currentPosition) {
    setState(() {
      if (_selectedRect != null) {
        _selectedRect = Rect.fromLTRB(
          _selectedRect!.left < currentPosition.dx
              ? _selectedRect!.left
              : currentPosition.dx,
          _selectedRect!.top < currentPosition.dy
              ? _selectedRect!.top
              : currentPosition.dy,
          _selectedRect!.right > currentPosition.dx
              ? _selectedRect!.right
              : currentPosition.dx,
          _selectedRect!.bottom > currentPosition.dy
              ? _selectedRect!.bottom
              : currentPosition.dy,
        );
      }
    });
  }

  Future<void> _showBottomSheet(BuildContext context) async {
    String annotationText = "";

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.white,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return Padding(
          padding: EdgeInsets.only(
            bottom: MediaQuery.of(context).viewInsets.bottom,
            top: 16,
            left: 16,
            right: 16,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TextField(
                decoration: const InputDecoration(
                  labelText: "Enter annotation",
                  border: OutlineInputBorder(),
                ),
                minLines: 3,
                maxLines: 8,
                onChanged: (value) {
                  annotationText = value;
                },
              ),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () async {
                  if (annotationText.isNotEmpty && _selectedRect != null) {
                    bool success = await _annotationController.saveAnnotation(
                      workRoomId: widget.workRoomId,
                      fileName: widget.fileName,
                      page: 0,
                      rect: _selectedRect!,
                      text: annotationText,
                      imageBytes: null,
                    );

                    if (success) {
                      Navigator.pop(context);
                      setState(() {
                        _selectedRect = null;
                      });
                    } else {
                      print("Failed to save annotation");
                    }
                  }
                },
                child: const Text("Save"),
              ),
              const SizedBox(height: 16),
            ],
          ),
        );
      },
    );
  }
  @override
  Widget build(BuildContext context) {
    super.build(context);
    final FileViewController controller = Get.find<FileViewController>();

    return Obx(() {
      if (controller.isLoading.value) {
        return const Center(child: CircularProgressIndicator());
      }

      if (controller.errorMessage.isNotEmpty) {
        return Center(child: Text(controller.errorMessage.value));
      }

      if (controller.file.value == null) {
        return const Center(child: Text("File not found."));
      }

      final file = controller.file.value!;
      return Stack(
        children: [
          GestureDetector(
            onPanStart: _isAnnotationMode
                ? (details) => _startDrawing(details.localPosition)
                : null,
            onPanUpdate: _isAnnotationMode
                ? (details) => _updateDrawing(details.localPosition)
                : null,
            onTapUp: _isAnnotationMode
                ? (details) async => await _showBottomSheet(context)
                : null,
            child: Image.file(
              file,
              key: _imageViewKey,
              fit: BoxFit.contain,
            ),
          ),
          if (_selectedRect != null)
            Positioned.fromRect(
              rect: _selectedRect!,
              child: Container(
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.red, width: 2),
                  color: Colors.red.withOpacity(0.2),
                ),
              ),
            ),
          Positioned(
            bottom: 16,
            right: 16,
            child: FloatingActionButton(
              onPressed: () =>
                  setState(() => _isAnnotationMode = !_isAnnotationMode),
              backgroundColor: Colors.blue,
              child: Icon(_isAnnotationMode ? Icons.close : Icons.comment,
                  color: Colors.white),
            ),
          ),
        ],
      );
    });
  }
}


// ===== FILE: ./lib/features/files/presentation/pdf_file_view_screen.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_pdfview/flutter_pdfview.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/document_annotation/annotation_controller.dart';
import 'package:legalfactfinder2025/features/document_annotation/data/document_annotation_model.dart';
import 'package:legalfactfinder2025/features/document_annotation/presentation/widgets/annotation_overlay.dart';
import 'package:legalfactfinder2025/features/files/file_view_controller.dart';
import 'package:legalfactfinder2025/features/files/presentation/widgets/draggable_page_controller.dart';
import 'package:legalfactfinder2025/features/files/presentation/widgets/pdf_page_controller.dart';
import 'package:legalfactfinder2025/features/document_annotation/presentation/widgets/input_annotation_bottom_sheet.dart';

class PDFFileViewScreen extends StatefulWidget {
  final String workRoomId;
  final String fileName;

  const PDFFileViewScreen({
    Key? key,
    required this.workRoomId,
    required this.fileName,
  }) : super(key: key);

  @override
  _PDFFileViewScreenState createState() => _PDFFileViewScreenState();
}

class _PDFFileViewScreenState extends State<PDFFileViewScreen>
    with AutomaticKeepAliveClientMixin {
  @override
  bool get wantKeepAlive => true;

  final GlobalKey _pdfViewKey = GlobalKey();
  PDFViewController? _pdfViewController;
  int _currentPage = 0;
  int _totalPages = 0;
  bool _isAnnotationMode = false;
  Rect? _selectedRect;
  bool _isPdfLoaded = false;
  int _targetPage = 0; // 🟡 추가: 이동할 대상 페이지 번호

  // 페이지별 저장된 주석 리스트
  Map<int, List<DocumentAnnotationModel>> _annotationsByPage = {};
  final AnnotationController _annotationController = Get.find<AnnotationController>();

  @override
  void initState() {
    super.initState();
    final FileViewController controller = Get.find<FileViewController>();
    controller.loadFile(
      'work_room_files',
      '${widget.workRoomId}/${widget.fileName}',
      widget.fileName,
    );
    // ✅ 주석 불러오기
    _annotationController.fetchAnnotations(widget.fileName);
  }

  void _toggleAnnotationMode() {
    setState(() {
      _isAnnotationMode = !_isAnnotationMode;

      if (_isAnnotationMode) {
        final screenWidth = MediaQuery.of(context).size.width;
        final screenHeight = MediaQuery.of(context).size.height;
        const double defaultWidth = 200.0;
        const double defaultHeight = 150.0;

        _selectedRect = Rect.fromCenter(
          center: Offset(screenWidth / 2, screenHeight / 2),
          width: defaultWidth,
          height: defaultHeight,
        );
      } else {
        _selectedRect = null;
      }
    });
  }

  void _onPageChanged(int page) {
    setState(() {
      _currentPage = page;
      _targetPage = page; // 🟡 추가: 이동할 페이지 번호 동기화

    });
  }


  void _saveAnnotation(String author, String text) async {
    if (_selectedRect != null) {
      bool success = await _annotationController.saveAnnotation(
        workRoomId: widget.workRoomId,
        fileName: widget.fileName,
        page: _currentPage,
        rect: _selectedRect!,
        text: text,
        imageBytes: null, // PDF 주석에서는 이미지 없음
      );

      if (success) {
        setState(() {
          _isAnnotationMode = false;
          _selectedRect = null;
        });
      } else {
        print("Failed to save annotation");
      }
    }
  }



  void _showAnnotationDetails(DocumentAnnotationModel annotation) {
    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.white,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(20)),
      ),
      builder: (context) {
        return Padding(
          padding: EdgeInsets.only(
            bottom: MediaQuery.of(context).viewInsets.bottom,
            top: 16,
            left: 16,
            right: 16,
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text("Annotation by ${annotation.createdBy}",
                  style: const TextStyle(fontWeight: FontWeight.bold)),
              const SizedBox(height: 8),
              Text(annotation.content ?? ""),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () => Navigator.pop(context),
                child: const Text("Close"),
              ),
            ],
          ),
        );
      },
    );
  }

  @override
  Widget build(BuildContext context) {
    super.build(context);

    final FileViewController controller = Get.find<FileViewController>();

    return Obx(() {
      if (controller.isLoading.value) {
        return const Center(
          child: CircularProgressIndicator(),
        );
      }

      if (controller.errorMessage.isNotEmpty) {
        return Center(child: Text(controller.errorMessage.value));
      }

      if (controller.file.value == null) {
        return const Center(child: Text("File not found."));
      }

      final file = controller.file.value!;
      return Column(
        children: [
          Expanded(
            child: Stack(
              children: [
                PDFView(
                  key: _pdfViewKey,
                  filePath: file.path,
                  swipeHorizontal: false,
                  enableSwipe: false,
                  pageFling: false,
                  pageSnap: false,
                  onRender: (pages) => setState(() => _totalPages = pages ?? 0),
                  onPageChanged: (page, _) => _onPageChanged(page ?? 0),
                  onViewCreated: (controller) =>
                      setState(() => _pdfViewController = controller),
                ),


                _buildDraggablePageController(), // ✅ 함수 호출하여 적용


                if (_isAnnotationMode && _selectedRect != null)
                  AnnotationOverlay(
                    annotation: DocumentAnnotationModel(
                      id: "temp",
                      // 임시 ID (편집 모드에서는 저장되지 않음)
                      documentId: null,
                      parentFileStorageKey: widget.fileName,
                      workRoomId: widget.workRoomId,
                      annotationType: "highlight",
                      pageNumber: _currentPage,
                      x1: _selectedRect!.left,
                      y1: _selectedRect!.top,
                      x2: _selectedRect!.right,
                      y2: _selectedRect!.bottom,
                      isOcr: false,
                      ocrText: null,
                      content: null,
                      createdBy: "Current User",
                      createdAt: DateTime.now(),
                      updatedAt: DateTime.now(),
                    ),
                    selectedRect: _selectedRect!,
                    isEditable: true,
                    onUpdate: (rect) => setState(() => _selectedRect = rect),
                    onIconTap: () {}, // 편집 모드에서는 아이콘 없음
                  ),
                if (_annotationsByPage.containsKey(_currentPage))
                  for (var annotation in _annotationsByPage[_currentPage]!)
                    AnnotationOverlay(
                      annotation: annotation,
                      selectedRect: Rect.fromLTRB(
                        annotation.x1 ?? 0.0,
                        annotation.y1 ?? 0.0,
                        annotation.x2 ?? 0.0,
                        annotation.y2 ?? 0.0,
                      ),
                      isEditable: false,
                      onUpdate: (rect) {},
                      // 읽기 모드에서는 크기 변경 불가
                      onIconTap: () => _showAnnotationDetails(annotation),
                    ),
                Positioned(
                  bottom: 80,
                  right: 16,
                  child: _isAnnotationMode
                      ? Column(
                          children: [
                            FloatingActionButton(
                              heroTag: "Cancel",
                              backgroundColor: Colors.red,
                              onPressed: _toggleAnnotationMode,
                              child:
                                  const Icon(Icons.close, color: Colors.white),
                            ),
                            const SizedBox(height: 8),
                            FloatingActionButton(
                              heroTag: "Confirm",
                              backgroundColor: Colors.green,
                              onPressed: () {
                                showModalBottomSheet(
                                  context: context,
                                  isScrollControlled: true,
                                  builder: (context) {
                                    return InputAnnotationBottomSheet(
                                      onSave: (text) => _saveAnnotation(
                                          "Current User", text), // 타입 불일치 해결
                                    );
                                  },
                                );
                              },
                              child:
                                  const Icon(Icons.check, color: Colors.white),
                            ),
                          ],
                        )
                      : FloatingActionButton(
                          onPressed: _toggleAnnotationMode,
                          backgroundColor: Colors.blue,
                          child: const Icon(Icons.add_comment,
                              color: Colors.white),
                        ),
                ),
              ],
            ),
          ),

          if (_pdfViewController != null)
            Padding(
              padding: EdgeInsets.only(
                  bottom: MediaQuery.of(context).padding.bottom / 2),
              child: PdfPageController(
                currentPage: _currentPage,
                totalPages: _totalPages,
                pdfViewController: _pdfViewController!,
              ),
            ),
        ],
      );
    });
  }

  void _moveToPage(int page) {
    // 🔴 추가: 특정 페이지로 이동하는 함수
    if (_pdfViewController != null && page >= 0 && page < _totalPages) {
      _pdfViewController!.setPage(page);
    }
  }

  double _getControllerPosition() { // ✅ 추가: 현재 페이지에 따라 컨트롤러의 세로 위치 계산
    if (_totalPages == 0) return MediaQuery.of(context).size.height * 0.3;
    double availableHeight = MediaQuery.of(context).size.height * 0.6; // 전체 높이의 60% 범위에서 이동
    return (availableHeight / (_totalPages - 1)) * _currentPage + MediaQuery.of(context).size.height * 0.2;
  }
  Widget _buildDraggablePageController() {
    if (_pdfViewController == null || _totalPages <= 1) return SizedBox.shrink();

    double availableHeight = MediaQuery.of(context).size.height
        - kToolbarHeight // AppBar 높이 제외
        - kBottomNavigationBarHeight // 하단 페이지 컨트롤러 제외
        - MediaQuery.of(context).padding.top // 상단 상태 바 제외
        - MediaQuery.of(context).padding.bottom / 2; // 하단 SafeArea 고려
    double bottomLimit = kBottomNavigationBarHeight + 16; // ✅ PdfPageController보다 내려가지 않도록 제한

    return Positioned(
      right: 16,
      child: DraggablePageController(
        pdfViewController: _pdfViewController!,
        currentPage: _currentPage,
        totalPages: _totalPages,
        availableHeight: availableHeight,
        bottomLimit: bottomLimit, // ✅ 하단 제한 추가
        onUpdate: (page) => setState(() => _targetPage = page),
        onRelease: (page) => _moveToPage(page),
      ),
    );
  }

}


// ===== FILE: ./lib/features/files/presentation/test_syncfusion_pdf_file_view_page.dart =====

import 'package:flutter/material.dart';
import 'package:syncfusion_flutter_pdfviewer/pdfviewer.dart';

class TestSyncfusionPdfFileViewPage extends StatefulWidget {
  const TestSyncfusionPdfFileViewPage({super.key});

  @override
  _TestSyncfusionPdfFileViewPageState createState() => _TestSyncfusionPdfFileViewPageState();
}

class _TestSyncfusionPdfFileViewPageState extends State<TestSyncfusionPdfFileViewPage> {
  final GlobalKey<SfPdfViewerState> _pdfViewerKey = GlobalKey();
  PdfViewerController _pdfController = PdfViewerController();
  bool _isCommentMode = false;
  bool _pdfScrollable = true;
  Rect? _selectedRegion;
  int? _selectedPage;
  final List<CommentBox> _commentBoxes = [];

  @override
  void initState() {
    super.initState();
    _pdfController.addListener(() {
      setState(() {});
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Syncfusion Flutter PDF Viewer'),
        actions: <Widget>[
          IconButton(
            icon: const Icon(Icons.bookmark),
            onPressed: () {
              _pdfViewerKey.currentState?.openBookmarkView();
            },
          ),
        ],
      ),
      body: Stack(
        children: [
          Listener(
            onPointerMove: _pdfScrollable ? null : (event) {},
            child: SfPdfViewer.network(
              'https://cdn.syncfusion.com/content/PDFViewer/flutter-succinctly.pdf',
              key: _pdfViewerKey,
              controller: _pdfController,
              interactionMode: _pdfScrollable ? PdfInteractionMode.selection : PdfInteractionMode.pan,
              onTap: (details) {
                if (_isCommentMode) {
                  int currentPage = _pdfController.pageNumber;
                  setState(() {
                    _selectedRegion = Rect.fromLTWH(
                      details.position.dx,
                      details.position.dy,
                      100,
                      50,
                    );
                    _selectedPage = currentPage;
                  });
                }
              },
            ),
          ),
          if (_isCommentMode && _selectedRegion != null && _selectedPage != null)
            Positioned(
              left: _selectedRegion!.left,
              top: _selectedRegion!.top,
              child: GestureDetector(
                onPanUpdate: (details) {
                  setState(() {
                    _selectedRegion = _selectedRegion!.translate(details.delta.dx, details.delta.dy);
                  });
                },
                child: Container(
                  width: _selectedRegion!.width,
                  height: _selectedRegion!.height,
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.red, width: 2),
                    color: Colors.red.withOpacity(0.2),
                  ),
                  child: Center(
                    child: IconButton(
                      icon: const Icon(Icons.add_comment, color: Colors.white),
                      onPressed: () => _addCommentDialog(_selectedPage!, _selectedRegion!),
                    ),
                  ),
                ),
              ),
            ),
          for (final commentBox in _commentBoxes.where((c) => c.pageNumber == _pdfController.pageNumber))
            Positioned(
              left: commentBox.rect.left,
              top: commentBox.rect.top,
              child: GestureDetector(
                onTap: () => _showComment(commentBox.comment),
                child: Container(
                  width: commentBox.rect.width,
                  height: commentBox.rect.height,
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.blue, width: 2),
                    color: Colors.blue.withOpacity(0.2),
                  ),
                  child: const Center(child: Icon(Icons.comment, color: Colors.white)),
                ),
              ),
            ),
          Positioned(
            right: 20,
            top: 20,
            child: FloatingActionButton(
              child: Icon(_isCommentMode ? Icons.close : Icons.mode_comment),
              onPressed: () {
                setState(() {
                  _isCommentMode = !_isCommentMode;
                  _pdfScrollable = !_isCommentMode;
                  _selectedRegion = null;
                  _selectedPage = null;
                });
              },
            ),
          ),
        ],
      ),
    );
  }

  void _addCommentDialog(int pageNumber, Rect position) {
    final TextEditingController controller = TextEditingController();
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Add Comment'),
          content: TextField(controller: controller, decoration: const InputDecoration(hintText: 'Enter your comment')),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                setState(() {
                  if (controller.text.isNotEmpty) {
                    _commentBoxes.add(CommentBox(
                      pageNumber,
                      position,
                      controller.text,
                    ));
                  }
                  _selectedRegion = null;
                  _isCommentMode = false;
                  _pdfScrollable = true;
                });
                Navigator.pop(context);
              },
              child: const Text('Save'),
            ),
          ],
        );
      },
    );
  }

  void _showComment(String comment) {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Comment'),
          content: Text(comment),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('OK'),
            ),
          ],
        );
      },
    );
  }
}

class CommentBox {
  final int pageNumber;
  final Rect rect;
  final String comment;

  CommentBox(this.pageNumber, this.rect, this.comment);
}


// ===== FILE: ./lib/features/files/presentation/file_annotation_threads_screen.dart =====

import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/document_annotation/annotation_controller.dart';
import 'package:legalfactfinder2025/features/document_annotation/data/annotation_repository.dart';
import 'package:legalfactfinder2025/features/document_annotation/data/document_annotation_model.dart';
import 'package:legalfactfinder2025/features/document_annotation/presentation/annotation_thread_screen.dart';

class FileAnnotationThreadsScreen extends StatefulWidget {
  final String workRoomId;
  final String fileName;
  final String parentFileStorageKey;

  const FileAnnotationThreadsScreen({
    Key? key,
    required this.workRoomId,
    required this.fileName,
    required this.parentFileStorageKey,
  }) : super(key: key);

  @override
  _FileAnnotationThreadsScreenState createState() =>
      _FileAnnotationThreadsScreenState();
}

class _FileAnnotationThreadsScreenState
    extends State<FileAnnotationThreadsScreen> with AutomaticKeepAliveClientMixin {
  final AnnotationController controller = Get.put(AnnotationController());
  final AnnotationRepository repository = AnnotationRepository();

  @override
  void initState() {
    super.initState();
    controller.fetchAnnotations(widget.parentFileStorageKey);
  }

  @override
  bool get wantKeepAlive => true;

  @override
  Widget build(BuildContext context) {
    super.build(context); // Required for AutomaticKeepAliveClientMixin

    return Obx(() {
      if (controller.isLoading.value) {
        return const Center(child: CircularProgressIndicator());
      }

      if (controller.errorMessage.isNotEmpty) {
        return Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(controller.errorMessage.value,
                  style: const TextStyle(color: Colors.red)),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () =>
                    controller.fetchAnnotations(widget.parentFileStorageKey),
                child: const Text("Retry"),
              ),
            ],
          ),
        );
      }

      if (controller.annotations.isEmpty) {
        return const Center(child: Text("No annotations found."));
      }

      return ListView.separated(
        itemCount: controller.annotations.length,
        separatorBuilder: (context, index) => const Divider(height: 40, ),
        itemBuilder: (context, index) {
          final annotation = controller.annotations[index];

          // Extract details
          final imageStorageKey = annotation['image_file_storage_key'];
          final content = annotation['content'] ?? 'No Content';
          final username = annotation['username'] ?? 'Unknown User';
          final avatarUrl = annotation['avatar_url'];

          return GestureDetector(
            onTap: () {
              _showAnnotationThreadBottomSheet(context, annotation);
            },
            child: Container(
              margin: const EdgeInsets.all(8.0),

              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  if (imageStorageKey != null)
                    FutureBuilder<String>(
                      future: repository.getPublicUrl(imageStorageKey),
                      builder: (context, snapshot) {
                        if (snapshot.connectionState == ConnectionState.waiting) {
                          return const Center(
                            child: CircularProgressIndicator(),
                          );
                        }
                        if (snapshot.hasError) {
                          return Text(
                            "Error loading image: ${snapshot.error}",
                            style: const TextStyle(color: Colors.red),
                          );
                        }
                        if (snapshot.hasData) {
                          return Container(
                            decoration: BoxDecoration(
                              border: Border.all(color: Colors.grey),
                            ),
                            child: Image.network(
                              snapshot.data!,
                              fit: BoxFit.contain, // Ensures the full image is visible without clipping
                              width: double.infinity, // Takes up the full width of the container
                            ),
                          );
                        }
                        return const Text("No image available.");
                      },
                    ),
                  ListTile(
                    leading: avatarUrl != null
                        ? CircleAvatar(
                      backgroundImage: NetworkImage(avatarUrl),
                    )
                        : const CircleAvatar(
                      child: Icon(Icons.person),
                    ),
                    title: Text(username),
                    subtitle: Text(content),
                  ),
                  // Text(JsonEncoder.withIndent('  ').convert(annotation))
                ],
              ),
            ),
          );
        },
      );
    });
  }

  /// Show the Bottom Sheet with annotation threads
  void _showAnnotationThreadBottomSheet(
      BuildContext context, Map<String, dynamic> annotationData) {
    final annotation = DocumentAnnotationModel.fromJson(annotationData); // Convert map to model

    showModalBottomSheet(
      context: context,
      isScrollControlled: true,
      backgroundColor: Colors.white,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(
          top: Radius.circular(20),
        ),
      ),
      builder: (context) {
        return DraggableScrollableSheet(
          initialChildSize: 0.9, // 90% of the screen
          maxChildSize: 0.9,
          minChildSize: 0.4,
          expand: false,
          builder: (context, scrollController) {
            return AnnotationThreadScreen(
              annotation: annotation,
              scrollController: scrollController,
            );
          },
        );
      },
    );
  }
}


// ===== FILE: ./lib/features/files/presentation/files_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:file_picker/file_picker.dart';
import 'package:legalfactfinder2025/features/authentication/auth_controller.dart';
import 'package:legalfactfinder2025/features/files/file_list_controller.dart';
import 'package:legalfactfinder2025/features/files/presentation/file_page.dart';
import 'package:legalfactfinder2025/features/files/presentation/widgets/file_action_menu.dart';

class FilesScreen extends StatelessWidget {
  final String workRoomId;
  final FileListController controller = Get.put(FileListController());

  FilesScreen({Key? key, required this.workRoomId}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    print("Building FilesScreen UI inside TabView for workRoomId: $workRoomId");

    // Load files for the given workRoomId when the screen opens
    controller.fetchFiles(workRoomId);

    return Stack(
      children: [
        Obx(() {
          print(
              "Rebuilding UI based on controller state for workRoomId: $workRoomId");

          if (controller.isLoading.value) {
            print("Files are loading for workRoomId: $workRoomId");
            return const Center(child: CircularProgressIndicator());
          }

          if (controller.errorMessage.isNotEmpty) {
            print("Error: ${controller.errorMessage.value}");
            WidgetsBinding.instance.addPostFrameCallback((_) {
              showDialog(
                context: context,
                builder: (context) {
                  return AlertDialog(
                    title: const Text('Error'),
                    content: Text(controller.errorMessage.value),
                    actions: [
                      TextButton(
                        onPressed: () {
                          controller.errorMessage.value = '';
                          Navigator.of(context).pop();
                        },
                        child: const Text('OK'),
                      ),
                    ],
                  );
                },
              );
            });
          }

          if (controller.files.isEmpty) {
            print("No files available for workRoomId: $workRoomId");
            return const Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(
                    Icons.folder_off,
                    size: 80,
                    color: Colors.grey,
                  ),
                  SizedBox(height: 16),
                  Text(
                    'No files uploaded yet.',
                    style: TextStyle(fontSize: 16, color: Colors.grey),
                  ),
                ],
              ),
            );
          }

          print(
              "Loaded ${controller.files.length} files for workRoomId: $workRoomId");

          return ListView.separated(
            itemCount: controller.files.length,
            separatorBuilder: (context, index) => const Divider(),
            itemBuilder: (context, index) {
              final file = controller.files[index];
              print(
                  "Rendering file: ${file.fileName} for workRoomId: $workRoomId");
              return ListTile(
                leading: Icon(
                  _getFileIcon(file.fileType),
                  size: 40,
                ),
                title: Text(
                  file.fileName,
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                subtitle: Text(
                  file.description ?? 'No description available',
                  maxLines: 1,
                  overflow: TextOverflow.ellipsis,
                ),
                trailing: FileActionMenu(file: file),
                onTap: () {
                  print(
                      "File tapped: ${file.fileName} for workRoomId: ${workRoomId} storageKey: ${file.storageKey}");
                  Get.to(() => FilePage(
                        workRoomId: workRoomId,
                        fileName: file.fileName,
                        storageKey: file.storageKey,
                      ));
                },
              );
            },
          );
        }),

        /// FAB를 항상 하단에 고정
        Positioned(
          bottom: 16,
          right: 16,
          child: FloatingActionButton(
            onPressed: () async {
              AuthController authController = Get.find<AuthController>();
              String? myUserId = authController.getUserId();
              if (myUserId == null) {
                Get.toNamed('/login');
                return;
              }
              print("FloatingActionButton pressed for workRoomId: $workRoomId");
              final filePath = await _pickFile();
              if (filePath != null) {
                print("File selected: $filePath for workRoomId: $workRoomId");
                controller.uploadFile(
                  filePath,
                  filePath.split('/').last, // 파일 이름 추출
                  'Sample description', // 설명 (사용자 입력 가능)
                  workRoomId, // 동적으로 workRoomId 사용
                 myUserId, // 실제 업로더 ID로 변경 필요
                );
              } else {
                print("No file selected for workRoomId: $workRoomId");
              }
            },
            child: const Icon(Icons.upload),
          ),
        ),
      ],
    );
  }

  // 파일 선택 메서드
  Future<String?> _pickFile() async {
    print("Opening file picker...");
    final result = await FilePicker.platform.pickFiles();
    if (result != null) {
      print("File picked: ${result.files.single.path}");
      return result.files.single.path;
    }
    print("File picker canceled.");
    return null;
  }

  // 파일 유형에 따라 아이콘 선택
  IconData _getFileIcon(String fileType) {
    print("Getting icon for fileType: $fileType");
    switch (fileType.toLowerCase()) {
      case 'pdf':
        return Icons.picture_as_pdf;
      case 'doc':
      case 'docx':
        return Icons.description;
      case 'jpg':
      case 'jpeg':
      case 'png':
        return Icons.image;
      case 'mp4':
      case 'mov':
        return Icons.video_library;
      default:
        return Icons.insert_drive_file;
    }
  }
}


// ===== FILE: ./lib/features/files/presentation/test_pdf_file_view_page.dart =====

import 'dart:async';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_pdfview/flutter_pdfview.dart';
import 'package:path_provider/path_provider.dart';
import 'dart:developer';

class TestPDFViewPage extends StatefulWidget {
  @override
  _TestPDFViewPageState createState() => _TestPDFViewPageState();
}

class _TestPDFViewPageState extends State<TestPDFViewPage> {
  bool isDrawingEnabled = false;
  List<Map<String, dynamic>> drawnRectangles = []; // 모든 페이지의 사각형 저장
  Rect? tempRectangle;
  Offset? startDrag;
  PDFViewController? pdfViewController;
  String pdfPath = "";
  int currentPage = 0;

  @override
  void initState() {
    super.initState();
    log("TestPDFViewPage initialized");
    _loadPdfFromAssets("assets/test/test.pdf").then((path) {
      setState(() {
        pdfPath = path;
        log("PDF loaded from assets: $pdfPath");
      });
    }).catchError((error) {
      log("Error loading PDF: $error");
    });
  }

  Future<String> _loadPdfFromAssets(String assetPath) async {
    try {
      var dir = await getApplicationDocumentsDirectory();
      File file = File("${dir.path}/temp.pdf");
      var data = await rootBundle.load(assetPath);
      var bytes = data.buffer.asUint8List();
      await file.writeAsBytes(bytes, flush: true);
      return file.path;
    } catch (e) {
      throw Exception('Error parsing asset file: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    log("Building TestPDFViewPage UI");
    return Scaffold(
      appBar: AppBar(
        title: Text("PDF Viewer"),
        actions: [
          IconButton(
            icon: Icon(isDrawingEnabled ? Icons.edit_off : Icons.edit),
            onPressed: () {
              setState(() {
                isDrawingEnabled = !isDrawingEnabled;
                log("Drawing mode toggled: $isDrawingEnabled");
              });
            },
          )
        ],
      ),
      body: pdfPath.isEmpty
          ? Center(child: CircularProgressIndicator())
          : Stack(
        children: [
          GestureDetector(
            onPanStart: isDrawingEnabled
                ? (details) {
              log("Pan started at: ${details.localPosition}");
              setState(() {
                startDrag = details.localPosition;
              });
            }
                : null,
            onPanUpdate: isDrawingEnabled
                ? (details) {
              log("Pan updated at: ${details.localPosition}");
              setState(() {
                if (startDrag != null) {
                  tempRectangle = Rect.fromPoints(
                      startDrag!, details.localPosition);
                }
              });
            }
                : null,
            onPanEnd: isDrawingEnabled
                ? (details) {
              log("Pan ended");
              setState(() {
                if (tempRectangle != null) {
                  drawnRectangles.add({
                    "rect": tempRectangle!,
                    "page": currentPage
                  });
                  log("Rectangle added: $tempRectangle on page: $currentPage");
                  tempRectangle = null;
                }
              });
            }
                : null,
            child: PDFView(
              filePath: pdfPath,
              enableSwipe: true,
              swipeHorizontal: false,
              autoSpacing: true,
              pageFling: true,
              onViewCreated: (controller) {
                log("PDFView created");
                pdfViewController = controller;
              },
              onPageChanged: (page, total) {
                log("PDF page changed: $page/$total");
                setState(() {
                  currentPage = page ?? 0;
                });
              },
              onError: (error) {
                log("PDF error: $error");
              },
            ),
          ),
          // 현재 페이지에 해당하는 사각형만 그리기
          ...drawnRectangles
              .where((rectData) => rectData["page"] == currentPage)
              .map((rectData) {
            final rect = rectData["rect"];
            if (rect is Rect) {
              return Positioned(
                left: rect.left,
                top: rect.top,
                width: rect.width,
                height: rect.height,
                child: Container(
                  decoration: BoxDecoration(
                    border: Border.all(color: Colors.red, width: 2),
                  ),
                ),
              );
            } else {
              log("Invalid rectangle data: $rectData");
              return SizedBox();
            }
          }).toList(),
          // 임시 사각형 그리기
          if (tempRectangle != null)
            Positioned(
              left: tempRectangle!.left,
              top: tempRectangle!.top,
              width: tempRectangle!.width,
              height: tempRectangle!.height,
              child: Container(
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.blue, width: 2),
                ),
              ),
            ),
        ],
      ),
    );
  }
}

// ===== FILE: ./lib/features/files/presentation/file_view_layout.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/files/presentation/pdf_file_view_screen.dart';
import 'package:legalfactfinder2025/features/files/presentation/image_file_view_screen.dart';

class FileViewLayout extends StatelessWidget {
  final String workRoomId;
  final String fileName;

  const FileViewLayout({
    Key? key,
    required this.workRoomId,
    required this.fileName,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final String fileExtension = fileName.split('.').last.toLowerCase();
    final bool isPdf = fileExtension == 'pdf';

    return isPdf
        ? PDFFileViewScreen(workRoomId: workRoomId, fileName: fileName)
        : ImageFileViewScreen(workRoomId: workRoomId, fileName: fileName);
  }
}


// ===== FILE: ./lib/features/files/presentation/file_page.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/files/presentation/file_annotation_threads_screen.dart';
import 'package:legalfactfinder2025/features/files/presentation/file_view_layout.dart';
import 'package:legalfactfinder2025/features/files/presentation/pdf_file_view_screen.dart';

class FilePage extends StatelessWidget {
  final String workRoomId;
  final String fileName;
  final String storageKey;

  const FilePage({
    Key? key,
    required this.workRoomId,
    required this.fileName,
    required this.storageKey,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 2,
      child: Scaffold(
        appBar: AppBar(
          title: GestureDetector(
            onTap: () {
              showDialog(
                context: context,
                builder: (BuildContext context) {
                  return AlertDialog(
                    title: const Text("File Name"),
                    content: SelectableText(fileName),
                    actions: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: const Text("Close"),
                      ),
                    ],
                  );
                },
              );
            },
            child: Text(
              fileName,
              overflow: TextOverflow.ellipsis, // 긴 파일명을 줄여서 표시
            ),
          ),
          bottom: PreferredSize(
            preferredSize: const Size.fromHeight(48),
            child: TabBar(
              indicator: const BoxDecoration(),
              indicatorColor: Colors.transparent,
              labelColor: Colors.blue,
              unselectedLabelColor: Colors.grey,
              tabs: const [
                Tab(icon: Icon(Icons.file_present, size: 20)),
                Tab(icon: Icon(Icons.comment, size: 20)),
              ],
            ),
          ),
        ),
        body: TabBarView(
          physics: const NeverScrollableScrollPhysics(),
          children: [
            FileViewLayout(
              workRoomId: workRoomId,
              fileName: fileName,
            ),
            FileAnnotationThreadsScreen(
              workRoomId: workRoomId,
              fileName: fileName,
              parentFileStorageKey: storageKey,
            ),
          ],
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/files/presentation/widgets/draggable_page_controller.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_pdfview/flutter_pdfview.dart';

class DraggablePageController extends StatefulWidget {
  final int currentPage;
  final int totalPages;
  final double availableHeight;
  final double bottomLimit; // ✅ 하단 제한 추가
  final Function(int) onUpdate;
  final Function(int) onRelease;
  final PDFViewController pdfViewController;

  const DraggablePageController({
    Key? key,
    required this.currentPage,
    required this.totalPages,
    required this.availableHeight,
    required this.bottomLimit, // ✅ 하단 제한 받음
    required this.onUpdate,
    required this.onRelease,    required this.pdfViewController,

  }) : super(key: key);

  @override
  _DraggablePageControllerState createState() =>
      _DraggablePageControllerState();
}


class _DraggablePageControllerState extends State<DraggablePageController> {
  double _currentY = 0;
  int _displayPage = 0;
  double _startY = 0;
  @override
  void initState() {
    super.initState();
    _updateControllerPosition();
  }

  @override
  void didUpdateWidget(covariant DraggablePageController oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.currentPage != oldWidget.currentPage) {
      _updateControllerPosition();
    }
  }

  void _updateControllerPosition() { // ✅ 현재 페이지에 맞게 위치 조정
    setState(() {
      if (widget.totalPages > 1) {
        _currentY = (widget.availableHeight / (widget.totalPages - 1)) * widget.currentPage;
        _displayPage = widget.currentPage;
      }
    });
  }

  int _calculatePageFromPosition(double position) { // ✅ 컨트롤러 위치를 페이지 번호로 변환
    return ((position / widget.availableHeight) * (widget.totalPages - 1))
        .round()
        .clamp(0, widget.totalPages - 1);
  }

  void _onVerticalDragStart(DragStartDetails details) {
    _startY = details.globalPosition.dy;
  }

  void _onVerticalDragUpdate(DragUpdateDetails details) {
    setState(() {
      double newPosition = _currentY + details.delta.dy;
      newPosition = newPosition.clamp(0, widget.availableHeight - widget.bottomLimit); // ✅ 하단 제한 적용
      _currentY = newPosition;
      _displayPage = _calculatePageFromPosition(_currentY);
      widget.onUpdate(_displayPage);
    });
  }

  void _onVerticalDragEnd(DragEndDetails details) {
    widget.onRelease(_displayPage);
  }

  @override
  Widget build(BuildContext context) {
    return Positioned(
      right: 16,
      top: _currentY, // ✅ 위치 동적 업데이트
      child: GestureDetector(
        onVerticalDragStart: _onVerticalDragStart,
        onVerticalDragUpdate: _onVerticalDragUpdate,
        onVerticalDragEnd: _onVerticalDragEnd,
        child: Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: Colors.black.withOpacity(0.7),
            borderRadius: BorderRadius.circular(8),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                "${_displayPage + 1}",
                style: const TextStyle(color: Colors.white, fontSize: 14),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/files/presentation/widgets/file_action_menu.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/files/data/file_model.dart';
import 'package:legalfactfinder2025/features/files/file_list_controller.dart';


class FileActionMenu extends StatelessWidget {
  final FileData file;
  final FileListController controller = Get.find<FileListController>();

  FileActionMenu({Key? key, required this.file}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return PopupMenuButton<String>(
      onSelected: (value) => _handleMenuAction(context, value),
      itemBuilder: (BuildContext context) {
        return [
          const PopupMenuItem(
            value: 'download',
            child: Text('Download'),
          ),
          const PopupMenuItem(
            value: 'rename',
            child: Text('Rename'),
          ),
          const PopupMenuItem(
            value: 'delete',
            child: Text('Delete'),
          ),
        ];
      },
      icon: const Icon(Icons.more_vert),
    );
  }

  void _handleMenuAction(BuildContext context, String value) {
    switch (value) {
      case 'download':
        _downloadFile(context);
        break;
      case 'rename':
        _renameFile(context);
        break;
      case 'delete':
        _deleteFile(context);
        break;
    }
  }

  void _downloadFile(BuildContext context) {
    final savePath = '/${file.workRoomId}/${file.fileName}'; // Replace with proper save path
    controller.downloadFile(file.fileName, savePath);
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text('Downloading ${file.fileName}...')),
    );
  }

  void _renameFile(BuildContext context) {
    TextEditingController textController = TextEditingController(text: file.fileName);
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Rename File'),
          content: TextField(
            controller: textController,
            decoration: const InputDecoration(labelText: 'New File Name'),
          ),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                final newName = textController.text.trim();
                if (newName.isNotEmpty) {
                  // Call controller to rename the file
                  controller.fetchFiles(file.workRoomId); // Refresh the file list
                  Navigator.of(context).pop();
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(content: Text('Renamed to $newName')),
                  );
                }
              },
              child: const Text('Rename'),
            ),
          ],
        );
      },
    );
  }

  void _deleteFile(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('Delete File'),
          content: const Text('Are you sure you want to delete this file?'),
          actions: [
            TextButton(
              onPressed: () {
                Navigator.of(context).pop();
              },
              child: const Text('Cancel'),
            ),
            TextButton(
              onPressed: () {
                // Call controller to delete the file
                controller.files.remove(file); // Remove locally
                Navigator.of(context).pop();
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(content: Text('${file.fileName} deleted')),
                );
              },
              child: const Text('Delete'),
            ),
          ],
        );
      },
    );
  }
}


// ===== FILE: ./lib/features/files/presentation/widgets/file_card.dart =====



// ===== FILE: ./lib/features/files/presentation/widgets/upload_button.dart =====



// ===== FILE: ./lib/features/files/presentation/widgets/pdf_page_controller.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_pdfview/flutter_pdfview.dart';

class PdfPageController extends StatelessWidget {
  final int currentPage;
  final int totalPages;
  final PDFViewController pdfViewController;

  const PdfPageController({
    Key? key,
    required this.currentPage,
    required this.totalPages,
    required this.pdfViewController,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.black.withOpacity(0.7),
      height: 50,
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          IconButton(
            icon: const Icon(Icons.arrow_back, color: Colors.white),
            onPressed: () => pdfViewController.setPage(currentPage - 1),
          ),
          Text(
            "${currentPage + 1} / $totalPages",
            style: const TextStyle(color: Colors.white),
          ),
          IconButton(
            icon: const Icon(Icons.arrow_forward, color: Colors.white),
            onPressed: () => pdfViewController.setPage(currentPage + 1),
          ),
        ],
      ),
    );
  }
}


// ===== FILE: ./lib/features/files/presentation/widgets/page_controller_widget.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_pdfview/flutter_pdfview.dart';

class PageControllerWidget extends StatelessWidget {
  final int currentPage;
  final int totalPages;
  final PDFViewController? pdfViewController; // Nullable
  final double arrowSize; // 화살표 크기 조정 가능

  const PageControllerWidget({
    Key? key,
    required this.currentPage,
    required this.totalPages,
    this.pdfViewController, // Nullable
    this.arrowSize = 24.0, // 기본 화살표 크기 설정
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Align(
      alignment: Alignment.bottomCenter,
      child: Container(
        color: Colors.black.withOpacity(0.2), // 배경색 투명도 조정
        padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 20),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            // 이전 페이지 버튼
            IconButton(
              iconSize: arrowSize, // 화살표 크기 조정
              icon: const Icon(Icons.arrow_back, color: Colors.white),
              onPressed: pdfViewController != null && currentPage > 0
                  ? () async {
                await pdfViewController!.setPage(currentPage - 1);
              }
                  : null, // 버튼 비활성화 조건
            ),
            // 현재 페이지 상태
            Text(
              "Page ${currentPage + 1} of $totalPages",
              style: const TextStyle(color: Colors.white, fontSize: 16),
            ),
            // 다음 페이지 버튼
            IconButton(
              iconSize: arrowSize, // 화살표 크기 조정
              icon: const Icon(Icons.arrow_forward, color: Colors.white),
              onPressed: pdfViewController != null && currentPage < totalPages - 1
                  ? () async {
                await pdfViewController!.setPage(currentPage + 1);
              }
                  : null, // 버튼 비활성화 조건
            ),
          ],
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/files/presentation/widgets/pdf_view_widget.dart =====

import 'package:flutter/material.dart';
import 'package:flutter_pdfview/flutter_pdfview.dart';

class PDFViewWidget extends StatelessWidget {
  final String filePath;
  final Function(int) onPageChanged;
  final Function(PDFViewController) onViewCreated;

  const PDFViewWidget({
    Key? key,
    required this.filePath,
    required this.onPageChanged,
    required this.onViewCreated,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return PDFView(
      filePath: filePath,
      swipeHorizontal: false,
      enableSwipe: false,
      pageFling: false,
      pageSnap: false,
      onPageChanged: (page, _) => onPageChanged(page ?? 0),
      onViewCreated: onViewCreated,
    );
  }
}


// ===== FILE: ./lib/features/work_room/work_room_list_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_model.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_repository.dart';

class WorkRoomListController extends GetxController {
  final WorkRoomRepository repository = WorkRoomRepository();

  RxList<WorkRoom> workRooms = <WorkRoom>[].obs;
  RxBool isLoading = false.obs;
  RxString errorMessage = ''.obs;

  /// 특정 사용자의 WorkRoom 목록을 가져오는 함수
  Future<void> fetchWorkRooms(String userId) async {
    try {
      isLoading.value = true;
      errorMessage.value = '';

      // Fetch work rooms from the repository
      final fetchedWorkRooms = await repository.getWorkRoomsByUserId(userId);

      // Check if the fetched work rooms are null and handle it
      if (fetchedWorkRooms == null) {
        errorMessage.value = "No work rooms found for this user.";
      } else {
        workRooms.assignAll(fetchedWorkRooms);
      }
    } catch (e) {
      errorMessage.value = "Failed to load Work Rooms: $e";
    } finally {
      isLoading.value = false;
    }
  }
}


// ===== FILE: ./lib/features/work_room/work_room_request_controller.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_request_repository.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_request_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class WorkRoomRequestController extends GetxController {
  final WorkRoomRequestRepository repository = WorkRoomRequestRepository(Supabase.instance.client);

  var isLoading = false.obs;
  var successMessage = ''.obs;
  var errorMessage = ''.obs;
  var receivedRequests = <Map<String, dynamic>>[].obs;
  var sentRequests = <Map<String, dynamic>>[].obs;

  // ✅ WorkRoom 초대 요청 보내기
  Future<void> sendWorkRoomRequest(String requesterId, String recipientEmail, String workRoomId) async {
    try {
      final startTime = DateTime.now();
      debugPrint("🔄 [WorkRoomRequestController] Sending WorkRoom request from '$requesterId' to '$recipientEmail' for WorkRoom '$workRoomId' at $startTime");

      isLoading(true);
      successMessage('');
      errorMessage('');

      debugPrint("⏳ [WorkRoomRequestController] Calling repository.sendWorkRoomRequest...");
      final success = await repository.sendWorkRoomRequest(requesterId, recipientEmail, workRoomId);

      final endTime = DateTime.now();
      final duration = endTime.difference(startTime);
      debugPrint("✅ [WorkRoomRequestController] API call completed in ${duration.inMilliseconds}ms");

      if (success) {
        successMessage('WorkRoom request sent successfully.');
        debugPrint("📨 [WorkRoomRequestController] WorkRoom request successfully sent to $recipientEmail");

        fetchSentRequests(requesterId); // ✅ 보낸 요청 즉시 갱신
      } else {
        errorMessage('Failed to send WorkRoom request. User may not exist.');
        debugPrint("❌ [WorkRoomRequestController] WorkRoom request failed: User not found or another issue.");
      }
    } catch (e, stacktrace) {
      errorMessage('Error sending WorkRoom request.');
      debugPrint("❌ [WorkRoomRequestController] Exception occurred while sending WorkRoom request: $e");
      debugPrint("🔍 [WorkRoomRequestController] Stacktrace: $stacktrace");
    } finally {
      isLoading(false);
      debugPrint("🔄 [WorkRoomRequestController] Finished processing WorkRoom request.");
    }
  }

  // ✅ 받은 WorkRoom 초대 목록 불러오기
  Future<void> fetchReceivedRequests(String userId) async {
    try {
      debugPrint("🔄 [WorkRoomRequestController] Fetching received work room requests for user: $userId");

      isLoading(true);
      errorMessage('');

      List<WorkRoomRequest> requests = await repository.getReceivedRequests(userId);
      receivedRequests.assignAll(requests.map((e) => e.toJson()).toList());

      debugPrint("✅ [WorkRoomRequestController] Successfully fetched received work room requests.");
    } catch (e, stacktrace) {
      errorMessage('❌ Error fetching received work room requests');
      debugPrint("❌ Exception: $e");
      debugPrint("🔍 Stacktrace: $stacktrace");
    } finally {
      isLoading(false);
    }
  }

  // ✅ 보낸 WorkRoom 초대 목록 불러오기
  Future<void> fetchSentRequests(String userId) async {
    try {
      debugPrint("🔄 [WorkRoomRequestController] Fetching sent work room requests for user: $userId");

      isLoading(true);
      errorMessage('');

      List<WorkRoomRequest> requests = await repository.getSentRequests(userId);
      sentRequests.assignAll(requests.map((e) => e.toJson()).toList());

      debugPrint("✅ [WorkRoomRequestController] Successfully fetched sent work room requests.");
    } catch (e, stacktrace) {
      errorMessage('❌ Error fetching sent work room requests');
      debugPrint("❌ Exception: $e");
      debugPrint("🔍 Stacktrace: $stacktrace");
    } finally {
      isLoading(false);
    }
  }
}


// ===== FILE: ./lib/features/work_room/work_room_details_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_details_model.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_details_repository.dart';

class WorkRoomDetailsController extends GetxController {

  final WorkRoomDetailsRepository workRoomDetailsRepository = WorkRoomDetailsRepository();

  Rx<WorkRoomDetails?> workRoomDetails = Rx<WorkRoomDetails?>(null);

  // 상태 변수
  var workRoom = Rxn<WorkRoom>(); // Rxn: null을 허용하는 반응형 변수
  var isLoading = false.obs; // 로딩 상태
  var errorMessage = ''.obs; // 에러 메시지
  var successMessage = ''.obs; // 성공 메시지


  Future<void> fetchWorkRoomDetails(String workRoomId) async {
    try {
      isLoading.value = true;
      errorMessage.value = '';

      final details = await workRoomDetailsRepository.getWorkRoomDetails(workRoomId);
      workRoomDetails.value = details;
    } catch (e) {
      errorMessage.value = "Failed to load WorkRoom details: $e";
    } finally {
      isLoading.value = false;
    }
  }


}


// ===== FILE: ./lib/features/work_room/data/work_room_request_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'work_room_request_model.g.dart';

@JsonSerializable()
class WorkRoomRequest {
  final String id;
  final String requesterId;
  final String recipientId;
  final String workRoomId;
  final String status;
  final DateTime sentAt;
  final DateTime? respondedAt;

  WorkRoomRequest({
    required this.id,
    required this.requesterId,
    required this.recipientId,
    required this.workRoomId,
    required this.status,
    required this.sentAt,
    this.respondedAt,
  });

  factory WorkRoomRequest.fromJson(Map<String, dynamic> json) => _$WorkRoomRequestFromJson(json);

  Map<String, dynamic> toJson() => _$WorkRoomRequestToJson(this);
}
//flutter pub run build_runner build

// ===== FILE: ./lib/features/work_room/data/work_room_details_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'work_room_details_model.g.dart';

@JsonSerializable()
class WorkRoom {
  final String id;
  final String title; // 수정: name -> title
  final String description;
  final DateTime createdAt;
  final DateTime updatedAt;

  WorkRoom({
    required this.id,
    required this.title,
    required this.description,
    required this.createdAt,
    required this.updatedAt,
  });

  factory WorkRoom.fromJson(Map<String, dynamic> json) {
    return WorkRoom(
      id: json['id'] as String? ?? '',
      title: json['title'] as String? ?? '', // 수정된 컬럼명 반영
      description: json['description'] as String? ?? '',
      createdAt: DateTime.tryParse(json['created_at'] as String? ?? '') ?? DateTime.now(),
      updatedAt: DateTime.tryParse(json['updated_at'] as String? ?? '') ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toJson() => _$WorkRoomToJson(this);
}

@JsonSerializable()
class WorkRoomParticipant {
  final String id;
  final String workRoomId; // 수정: work_room_id 추가
  final String userId;
  final bool isAdmin;
  final DateTime joinedAt;
  final DateTime lastSeen;

  WorkRoomParticipant({
    required this.id,
    required this.workRoomId, // 추가된 필드
    required this.userId,
    required this.isAdmin,
    required this.joinedAt,
    required this.lastSeen,
  });

  factory WorkRoomParticipant.fromJson(Map<String, dynamic> json) {
    return WorkRoomParticipant(
      id: json['id'] as String? ?? '',
      workRoomId: json['work_room_id'] as String? ?? '', // 추가
      userId: json['user_id'] as String? ?? '',
      isAdmin: json['is_admin'] as bool? ?? false,
      joinedAt: DateTime.tryParse(json['joined_at'] as String? ?? '') ?? DateTime.now(),
      lastSeen: DateTime.tryParse(json['last_seen'] as String? ?? '') ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toJson() => _$WorkRoomParticipantToJson(this);
}

@JsonSerializable()
class WorkRoomParty {
  final String id;
  final String workRoomId;
  final String name;
  final String role;
  final DateTime createdAt;
  final DateTime updatedAt;

  WorkRoomParty({
    required this.id,
    required this.workRoomId,
    required this.name,
    required this.role,
    required this.createdAt,
    required this.updatedAt,
  });

  factory WorkRoomParty.fromJson(Map<String, dynamic> json) {
    return WorkRoomParty(
      id: json['id'] as String? ?? '',
      workRoomId: json['work_room_id'] as String? ?? '',
      name: json['name'] as String? ?? '',
      role: json['role'] as String? ?? '',
      createdAt: DateTime.tryParse(json['created_at'] as String? ?? '') ?? DateTime.now(),
      updatedAt: DateTime.tryParse(json['updated_at'] as String? ?? '') ?? DateTime.now(),
    );
  }

  Map<String, dynamic> toJson() => _$WorkRoomPartyToJson(this);
}

@JsonSerializable()
class WorkRoomDetails {
  final WorkRoom workRoom;
  final List<WorkRoomParticipant> participants;
  final List<WorkRoomParty> parties;

  WorkRoomDetails({
    required this.workRoom,
    required this.participants,
    required this.parties,
  });

  factory WorkRoomDetails.fromJson(Map<String, dynamic> json) {
    return WorkRoomDetails(
      workRoom: WorkRoom.fromJson(json['work_room'] as Map<String, dynamic>? ?? {}),
      participants: (json['participants'] as List<dynamic>?)
          ?.map((participant) => WorkRoomParticipant.fromJson(participant))
          .toList() ??
          [],
      parties: (json['parties'] as List<dynamic>?)
          ?.map((party) => WorkRoomParty.fromJson(party))
          .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() => _$WorkRoomDetailsToJson(this);
}


// ===== FILE: ./lib/features/work_room/data/work_room_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'work_room_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

WorkRoom _$WorkRoomFromJson(Map<String, dynamic> json) => WorkRoom(
      id: json['id'] as String,
      title: json['title'] as String,
      description: json['description'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      participants: (json['participants'] as List<dynamic>)
          .map((e) => Participant.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$WorkRoomToJson(WorkRoom instance) => <String, dynamic>{
      'id': instance.id,
      'title': instance.title,
      'description': instance.description,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
      'participants': instance.participants,
    };

Participant _$ParticipantFromJson(Map<String, dynamic> json) => Participant(
      userId: json['userId'] as String,
      isAdmin: json['isAdmin'] as bool,
      username: json['username'] as String,
      profilePictureUrl: json['profilePictureUrl'] as String,
      isLawyer: json['isLawyer'] as bool,
    );

Map<String, dynamic> _$ParticipantToJson(Participant instance) =>
    <String, dynamic>{
      'userId': instance.userId,
      'isAdmin': instance.isAdmin,
      'username': instance.username,
      'profilePictureUrl': instance.profilePictureUrl,
      'isLawyer': instance.isLawyer,
    };


// ===== FILE: ./lib/features/work_room/data/work_room_request_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'work_room_request_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

WorkRoomRequest _$WorkRoomRequestFromJson(Map<String, dynamic> json) =>
    WorkRoomRequest(
      id: json['id'] as String,
      requesterId: json['requesterId'] as String,
      recipientId: json['recipientId'] as String,
      workRoomId: json['workRoomId'] as String,
      status: json['status'] as String,
      sentAt: DateTime.parse(json['sentAt'] as String),
      respondedAt: json['respondedAt'] == null
          ? null
          : DateTime.parse(json['respondedAt'] as String),
    );

Map<String, dynamic> _$WorkRoomRequestToJson(WorkRoomRequest instance) =>
    <String, dynamic>{
      'id': instance.id,
      'requesterId': instance.requesterId,
      'recipientId': instance.recipientId,
      'workRoomId': instance.workRoomId,
      'status': instance.status,
      'sentAt': instance.sentAt.toIso8601String(),
      'respondedAt': instance.respondedAt?.toIso8601String(),
    };


// ===== FILE: ./lib/features/work_room/data/work_room_model.dart =====

import 'package:json_annotation/json_annotation.dart';

part 'work_room_model.g.dart';

@JsonSerializable()
class WorkRoom {
  final String id; // "id" 컬럼
  final String title; // "title" 컬럼
  final String description; // "description" 컬럼
  final DateTime createdAt; // "created_at" 컬럼
  final DateTime updatedAt; // "updated_at" 컬럼
  final List<Participant> participants;

  WorkRoom({
    required this.id,
    required this.title,
    required this.description,
    required this.createdAt,
    required this.updatedAt,
    required this.participants,
  });

  // Null-safe factory method for JSON deserialization
  factory WorkRoom.fromJson(Map<String, dynamic> json) {
    return WorkRoom(
      id: json['work_room_id'] as String? ?? '',
      title: json['title'] as String? ?? '',
      description: json['description'] as String? ?? '',
      createdAt: DateTime.tryParse(json['created_at'] as String? ?? '') ?? DateTime.now(),
      updatedAt: DateTime.tryParse(json['updated_at'] as String? ?? '') ?? DateTime.now(),
      participants: (json['participants'] as List<dynamic>?)
          ?.map((participantJson) => Participant.fromJson(participantJson))
          .toList() ??
          [],
    );
  }

  Map<String, dynamic> toJson() => _$WorkRoomToJson(this);
}

@JsonSerializable()
class Participant {
  final String userId;
  final bool isAdmin;
  final String username;
  final String profilePictureUrl;
  final bool isLawyer;

  Participant({
    required this.userId,
    required this.isAdmin,
    required this.username,
    required this.profilePictureUrl,
    required this.isLawyer,
  });

  factory Participant.fromJson(Map<String, dynamic> json) {
    return Participant(
      userId: json['user_id'] as String? ?? '',
      isAdmin: json['is_admin'] as bool? ?? false,

      username: json['username'] as String? ?? '',
      profilePictureUrl: json['profile_picture_url'] as String? ?? '',
      isLawyer: json['is_lawyer'] as bool? ?? false,
    );
  }

  Map<String, dynamic> toJson() => _$ParticipantToJson(this);
}


// ===== FILE: ./lib/features/work_room/data/work_room_details_model.g.dart =====

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'work_room_details_model.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

WorkRoom _$WorkRoomFromJson(Map<String, dynamic> json) => WorkRoom(
      id: json['id'] as String,
      title: json['title'] as String,
      description: json['description'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );

Map<String, dynamic> _$WorkRoomToJson(WorkRoom instance) => <String, dynamic>{
      'id': instance.id,
      'title': instance.title,
      'description': instance.description,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
    };

WorkRoomParticipant _$WorkRoomParticipantFromJson(Map<String, dynamic> json) =>
    WorkRoomParticipant(
      id: json['id'] as String,
      workRoomId: json['workRoomId'] as String,
      userId: json['userId'] as String,
      isAdmin: json['isAdmin'] as bool,
      joinedAt: DateTime.parse(json['joinedAt'] as String),
      lastSeen: DateTime.parse(json['lastSeen'] as String),
    );

Map<String, dynamic> _$WorkRoomParticipantToJson(
        WorkRoomParticipant instance) =>
    <String, dynamic>{
      'id': instance.id,
      'workRoomId': instance.workRoomId,
      'userId': instance.userId,
      'isAdmin': instance.isAdmin,
      'joinedAt': instance.joinedAt.toIso8601String(),
      'lastSeen': instance.lastSeen.toIso8601String(),
    };

WorkRoomParty _$WorkRoomPartyFromJson(Map<String, dynamic> json) =>
    WorkRoomParty(
      id: json['id'] as String,
      workRoomId: json['workRoomId'] as String,
      name: json['name'] as String,
      role: json['role'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
    );

Map<String, dynamic> _$WorkRoomPartyToJson(WorkRoomParty instance) =>
    <String, dynamic>{
      'id': instance.id,
      'workRoomId': instance.workRoomId,
      'name': instance.name,
      'role': instance.role,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
    };

WorkRoomDetails _$WorkRoomDetailsFromJson(Map<String, dynamic> json) =>
    WorkRoomDetails(
      workRoom: WorkRoom.fromJson(json['workRoom'] as Map<String, dynamic>),
      participants: (json['participants'] as List<dynamic>)
          .map((e) => WorkRoomParticipant.fromJson(e as Map<String, dynamic>))
          .toList(),
      parties: (json['parties'] as List<dynamic>)
          .map((e) => WorkRoomParty.fromJson(e as Map<String, dynamic>))
          .toList(),
    );

Map<String, dynamic> _$WorkRoomDetailsToJson(WorkRoomDetails instance) =>
    <String, dynamic>{
      'workRoom': instance.workRoom,
      'participants': instance.participants,
      'parties': instance.parties,
    };


// ===== FILE: ./lib/features/work_room/data/work_room_details_repository.dart =====

import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:legalfactfinder2025/constants.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_details_model.dart';

class WorkRoomDetailsRepository {
  Future<WorkRoomDetails> getWorkRoomDetails(String workRoomId) async {
    final url = Uri.parse('$baseUrl/functions/v1/get_work_room_details_json');

    print("🔵 [REQUEST] Fetching WorkRoom details for ID: $workRoomId from $url");

    try {
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $jwtToken',
        },
        body: jsonEncode({'work_room_id': workRoomId}),
      );

      print("🟢 [RESPONSE] Status Code: ${response.statusCode}");
      print("🟢 Raw Body: ${response.body}");

      if (response.statusCode == 200) {
        final decodedResponse = utf8.decode(response.bodyBytes);
        final responseData = jsonDecode(decodedResponse);

        print("🔹 Parsed JSON: $responseData");

        if (responseData is! Map<String, dynamic> || !responseData.containsKey('work_room_details')) {
          throw Exception("Unexpected response format: Missing 'work_room_details' key.");
        }

        final workRoomDetails = WorkRoomDetails.fromJson(responseData['work_room_details']);

        print("✅ Successfully fetched WorkRoom details!");
        return workRoomDetails;
      } else {
        print("❌ [ERROR] Failed to fetch WorkRoom details: ${response.body}");
        throw Exception("Failed to fetch WorkRoom details: ${response.body}");
      }
    } catch (e, stackTrace) {
      print("🚨 [EXCEPTION] Error fetching WorkRoom details");
      print("🔴 Exception: $e");
      print("🔴 Stack Trace: $stackTrace");
      throw Exception("An unexpected error occurred: $e");
    }
  }
}


// ===== FILE: ./lib/features/work_room/data/work_room_request_repository.dart =====

import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_request_model.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class WorkRoomRequestRepository {
  final SupabaseClient supabase;

  WorkRoomRequestRepository(this.supabase);

  // ✅ Supabase Edge Function `put_work_room_request` 호출하여 WorkRoom 요청 처리
  Future<bool> sendWorkRoomRequest(String requesterId, String recipientEmail, String workRoomId) async {
    try {
      debugPrint("🔄 [WorkRoomRequestRepository] Sending WorkRoom request from '$requesterId' to '$recipientEmail' for WorkRoom '$workRoomId'");

      final startTime = DateTime.now();
      debugPrint("⏳ [WorkRoomRequestRepository] Invoking Supabase Edge Function...");

      final responseEdge = await supabase.functions.invoke(
        'put_work_room_request',
        body: {
          'requester_id': requesterId,
          'recipient_email': recipientEmail,
          'work_room_id': workRoomId,
        },
      );

      final endTime = DateTime.now();
      final duration = endTime.difference(startTime);
      debugPrint("✅ [WorkRoomRequestRepository] Edge Function completed in ${duration.inMilliseconds}ms");

      if (responseEdge.data == null) {
        debugPrint("❌ [WorkRoomRequestRepository] No data received from Edge Function.");
        return false;
      }

      debugPrint("✅ [WorkRoomRequestRepository] WorkRoom request successfully sent via Edge Function.");
      return true;
    } catch (e, stacktrace) {
      debugPrint("❌ [WorkRoomRequestRepository] Error sending WorkRoom request: $e");
      debugPrint("🔍 [WorkRoomRequestRepository] Stacktrace: $stacktrace");
      return false;
    }
  }

  // ✅ 받은 WorkRoom 초대 목록 불러오기
  Future<List<WorkRoomRequest>> getReceivedRequests(String userId) async {
    try {
      debugPrint("🔄 [WorkRoomRequestRepository] Fetching received work room requests for user: $userId");

      final response = await supabase.functions.invoke(
        'get_received_work_room_requests',
        body: {'user_id': userId},
      );

      if (response.data == null) {
        debugPrint("❌ [WorkRoomRequestRepository] No data received.");
        return [];
      }

      // ✅ Ensure response.data is properly parsed as List<dynamic>
      List<dynamic> responseData;
      if (response.data is String) {
        responseData = jsonDecode(response.data);
      } else if (response.data is List) {
        responseData = response.data;
      } else {
        throw Exception("Unexpected response format: ${response.data}");
      }

      debugPrint("✅ [WorkRoomRequestRepository] Successfully fetched received work room requests.");
      return responseData.map((e) => WorkRoomRequest.fromJson(e as Map<String, dynamic>)).toList();
    } catch (e) {
      debugPrint("❌ [WorkRoomRequestRepository] Error fetching received requests: $e");
      return [];
    }
  }

  // ✅ 보낸 WorkRoom 초대 목록 불러오기
  Future<List<WorkRoomRequest>> getSentRequests(String userId) async {
    try {
      debugPrint("🔄 [WorkRoomRequestRepository] Fetching sent work room requests for user: $userId");

      final response = await supabase.functions.invoke(
        'get_sent_work_room_requests',
        body: {'user_id': userId},
      );

      if (response.data == null) {
        debugPrint("❌ [WorkRoomRequestRepository] No data received.");
        return [];
      }

      // ✅ Ensure response.data is properly parsed as List<dynamic>
      List<dynamic> responseData;
      if (response.data is String) {
        responseData = jsonDecode(response.data);
      } else if (response.data is List) {
        responseData = response.data;
      } else {
        throw Exception("Unexpected response format: ${response.data}");
      }

      debugPrint("✅ [WorkRoomRequestRepository] Successfully fetched sent work room requests.");
      return responseData.map((e) => WorkRoomRequest.fromJson(e as Map<String, dynamic>)).toList();
    } catch (e) {
      debugPrint("❌ [WorkRoomRequestRepository] Error fetching sent requests: $e");
      return [];
    }
  }
}


// ===== FILE: ./lib/features/work_room/data/work_room_repository.dart =====

import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:legalfactfinder2025/constants.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_model.dart';

class WorkRoomRepository {

  Future<List<WorkRoom>> getWorkRoomsByUserId(String userId) async {
    final url = Uri.parse('$baseUrl/functions/v1/get_work_rooms_by_user_id');

    print("🔵 [REQUEST] Fetching WorkRooms for userId: $userId from $url");

    try {
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $jwtToken',
        },
        body: jsonEncode({'p_user_id': userId}),
      );

      print("🟢 [RESPONSE] Status Code: ${response.statusCode}");
      print("🟢 Raw Body: ${response.body}");

      if (response.statusCode == 200) {
        final decodedResponse = utf8.decode(response.bodyBytes);
        final responseData = jsonDecode(decodedResponse);

        print("🔹 Parsed JSON: $responseData");

        // Check if 'work_rooms' is null or absent
        if (responseData is! Map<String, dynamic> || responseData['work_rooms'] == null) {
          print("🔴 No work rooms found or 'work_rooms' key is null.");
          return []; // Return an empty list if no work rooms are found
        }

        final workRooms = (responseData['work_rooms'] as List<dynamic>)
            .map((json) => WorkRoom.fromJson(json))
            .toList();

        print("✅ Successfully fetched ${workRooms.length} WorkRooms!");
        return workRooms;
      } else {
        print("❌ [ERROR] Failed to fetch WorkRooms: ${response.body}");
        throw Exception("Failed to fetch WorkRooms: ${response.body}");
      }
    } catch (e, stackTrace) {
      print("🚨 [EXCEPTION] Error fetching WorkRooms");
      print("🔴 Exception: $e");
      print("🔴 Stack Trace: $stackTrace");
      throw Exception("An unexpected error occurred: $e");
    }
  }



  Future<WorkRoom> getWorkRoomById(String workRoomId) async {
    final url = Uri.parse('$baseUrl/functions/v1/get_work_room_with_participants_json');

    print("🔵 [REQUEST] Fetching WorkRoom details for ID: $workRoomId from $url");

    try {
      final response = await http.post(
        url,
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $jwtToken',
        },
        body: jsonEncode({'p_work_room_id': workRoomId}),
      );

      print("🟢 [RESPONSE] Status Code: ${response.statusCode}");
      print("🟢 Raw Body: ${response.body}");

      if (response.statusCode == 200) {
        final decodedResponse = utf8.decode(response.bodyBytes);
        final responseData = jsonDecode(decodedResponse);

        print("🔹 Parsed JSON: $responseData");

        // Check for `work_room_with_participants` key
        if (responseData is! Map<String, dynamic> || !responseData.containsKey('work_room_with_participants')) {
          throw Exception("Unexpected response format: Missing 'work_room_with_participants' key.");
        }

        final workRoomWithParticipants = responseData['work_room_with_participants'];

        // Extract and parse `work_room`
        if (!workRoomWithParticipants.containsKey('work_room')) {
          throw Exception("Unexpected response format: Missing 'work_room' key.");
        }

        final workRoom = WorkRoom.fromJson(workRoomWithParticipants['work_room']);

        print("✅ Successfully fetched WorkRoom details!");
        return workRoom;
      } else {
        print("❌ [ERROR] Failed to fetch WorkRoom details: ${response.body}");
        throw Exception("Failed to fetch WorkRoom details: ${response.body}");
      }
    } catch (e, stackTrace) {
      print("🚨 [EXCEPTION] Error fetching WorkRoom details");
      print("🔴 Exception: $e");
      print("🔴 Stack Trace: $stackTrace");
      throw Exception("An unexpected error occurred: $e");
    }
  }



  // WorkRoom 생성
  Future<void> createWorkRoom(String title, String description, String userId) async {
    final response = await http.post(
      Uri.parse('$baseUrl/functions/v1/put_work_room'), // constants.dart에서 URL 사용
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer $jwtToken', // constants.dart에서 JWT Token 사용
      },
      body: jsonEncode({
        'title': title,
        'description': description,
        'user_id': userId,
      }),
    );

    if (response.statusCode != 200) {
      throw Exception('Failed to create WorkRoom: ${response.body}');
    }
  }
}


// ===== FILE: ./lib/features/work_room/domain/send_invitation_usecase.dart =====



// ===== FILE: ./lib/features/work_room/domain/accept_invitation_usecase.dart =====



// ===== FILE: ./lib/features/work_room/domain/fetch_work_rooms_usecase.dart =====



// ===== FILE: ./lib/features/work_room/presentation/add_work_room_page.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/authentication/auth_controller.dart';
import 'package:legalfactfinder2025/features/work_room/work_room_controller.dart';
import 'package:legalfactfinder2025/features/work_room/work_room_list_controller.dart';

class AddWorkRoomPage extends StatefulWidget {
  const AddWorkRoomPage({super.key});

  @override
  _AddWorkRoomPageState createState() => _AddWorkRoomPageState();
}

class _AddWorkRoomPageState extends State<AddWorkRoomPage> {
  final _formKey = GlobalKey<FormState>();
  final TextEditingController _titleController = TextEditingController();
  final TextEditingController _descriptionController = TextEditingController();

  late AuthController authController;
  late WorkRoomController workRoomController;
  String? userId;

  @override
  void initState() {
    super.initState();

    // GetX 컨트롤러 가져오기
    authController = Get.find<AuthController>();
    workRoomController = Get.find<WorkRoomController>();

    // 로그인 상태 체크 후 userId 가져오기
    userId = authController.getUserId();

    // 로그인하지 않은 경우 로그인 페이지로 이동
    if (userId == null) {
      Future.delayed(Duration.zero, () => Get.offAllNamed('/login'));
    }
  }

  @override
  Widget build(BuildContext context) {
    // 로그인하지 않은 경우, 로딩 화면을 표시 (Get.offAllNamed()가 실행될 때까지)
    if (userId == null) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      appBar: AppBar(title: const Text('Add Work Room')),
      body: Padding(
        padding: const EdgeInsets.all(20.0), // ✅ 전체 패딩 추가
        child: Obx(() {
          if (workRoomController.isLoading.value) {
            return const Center(child: CircularProgressIndicator());
          }

          return Form(
            key: _formKey,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text("Work Room Title", style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _titleController,
                  decoration: InputDecoration(
                    labelText: 'Enter title',
                    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14), // ✅ 여백 추가
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a title';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),

                const Text("Description", style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                const SizedBox(height: 8),
                TextFormField(
                  controller: _descriptionController,
                  maxLines: 3, // ✅ 입력 공간 확대
                  decoration: InputDecoration(
                    labelText: 'Enter description',
                    contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14), // ✅ 여백 추가
                    border: OutlineInputBorder(borderRadius: BorderRadius.circular(8)),
                  ),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return 'Please enter a description';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 30),

                // ✅ 버튼 디자인 개선 (너비 확장 + 패딩 추가)
                SizedBox(
                  width: double.infinity, // 버튼 너비 확장
                  child: ElevatedButton(
                    onPressed: () async {
                      if (_formKey.currentState!.validate()) {
                        await workRoomController.addWorkRoom(
                          _titleController.text,
                          _descriptionController.text,
                          userId!, // 로그인한 사용자 ID 사용 (null이 될 가능성 없음)
                        );

                        if (workRoomController.successMessage.isNotEmpty) {
                          // ✅ 추가 후 WorkRoom 목록 새로고침
                          final listController = Get.find<WorkRoomListController>();
                          listController.fetchWorkRooms(userId!);

                          _showSuccessSnackbar(workRoomController.successMessage.value);
                          Navigator.pop(context);
                        } else if (workRoomController.errorMessage.isNotEmpty) {
                          _showErrorDialog(context, workRoomController.errorMessage.value);
                        }
                      }
                    },
                    style: ElevatedButton.styleFrom(
                      padding: const EdgeInsets.symmetric(vertical: 14), // ✅ 버튼 내부 패딩 추가
                      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)), // ✅ 버튼 둥글기 조정
                    ),
                    child: const Text('Add Work Room', style: TextStyle(fontSize: 16)),
                  ),
                ),
              ],
            ),
          );
        }),
      ),
    );
  }

  // ✅ 성공 시 화면 상단에 SnackBar 표시
  void _showSuccessSnackbar(String message) {
    Get.snackbar(
      'Success',
      message,
      snackPosition: SnackPosition.TOP,
      backgroundColor: Colors.green.withOpacity(0.8),
      colorText: Colors.white,
      duration: const Duration(seconds: 2),
    );
  }

  // ✅ 에러 발생 시 AlertDialog 표시
  void _showErrorDialog(BuildContext context, String errorMessage) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Error'),
        content: Text(errorMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('OK'),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }
}


// ===== FILE: ./lib/features/work_room/presentation/work_room_list_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/work_room_requests_page.dart';
import 'package:legalfactfinder2025/features/work_room/work_room_list_controller.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_model.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/add_work_room_page.dart';

class WorkRoomListScreen extends StatefulWidget {
  final String myUserId;

  WorkRoomListScreen({Key? key, required this.myUserId}) : super(key: key);

  @override
  _WorkRoomListScreenState createState() => _WorkRoomListScreenState();
}

class _WorkRoomListScreenState extends State<WorkRoomListScreen> {
  late WorkRoomListController controller;

  @override
  void initState() {
    super.initState();
    controller = Get.find<WorkRoomListController>();
    print("WorkRoomListController retrieved from GetX");
    controller.fetchWorkRooms(widget.myUserId);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Stack(
        children: [
          Positioned.fill(
            child: Obx(() {
              if (controller.isLoading.value) {
                return _buildLoading();
              }
              if (controller.errorMessage.value.isNotEmpty) {
                return _buildError(controller.errorMessage.value);
              }
              if (controller.workRooms.isEmpty) {
                return _buildEmptyState();
              }
              return _buildWorkRoomList();
            }),
          ),
          // FAB 추가
          Positioned(
            bottom: 16.0,
            right: 16.0,
            child: FloatingActionButton(
              onPressed: () {
                _navigateToWorkRoomRequests(context);
              },
              child: Icon(Icons.mail_outline),
              tooltip: "View Work Room Invitations",
            ),
          )
        ],
      ),
    );
  }

  void _navigateToWorkRoomRequests(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(builder: (context) => WorkRoomRequestsPage()),
    );
  }

  // ✅ 로딩 화면
  Widget _buildLoading() {
    return const Center(child: CircularProgressIndicator());
  }

  // ✅ 에러 화면
  Widget _buildError(String errorMessage) {
    return Center(
      child: Text(
        errorMessage,
        style: const TextStyle(color: Colors.red, fontSize: 16),
      ),
    );
  }

  // ✅ Work Room이 없을 때 빈 화면 + 버튼 추가
  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Image.asset(
            // ✅ 생성된 이미지 적용
            'assets/images/workroom_placeholder.png',
            width: 200,
            height: 200,
          ),
          const SizedBox(height: 20),
          const Text(
            "아직 Work Room이 없습니다!",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 10),
          const Text(
            "새로운 Work Room을 만들어 협업을 시작하세요.",
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 14, color: Colors.grey),
          ),
          const SizedBox(height: 20),

          // ✅ Work Room 생성 버튼
          SizedBox(
            width: 200,
            child: ElevatedButton(
              onPressed: () {
                Get.to(() => AddWorkRoomPage()); // Work Room 생성 페이지 이동
              },
              child: const Text("내 첫 Work Room 만들기"),
            ),
          ),
        ],
      ),
    );
  }

  // ✅ Work Room 리스트 화면
  Widget _buildWorkRoomList() {
    return ListView.separated(
      padding: const EdgeInsets.symmetric(vertical: 8),
      itemCount: controller.workRooms.length,
      separatorBuilder: (context, index) =>
          const Divider(thickness: 1, height: 1),
      itemBuilder: (context, index) {
        final workRoom = controller.workRooms[index];
        return WorkRoomTile(workRoom: workRoom);
      },
    );
  }
}

class WorkRoomTile extends StatelessWidget {
  final WorkRoom workRoom;

  const WorkRoomTile({Key? key, required this.workRoom}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return InkWell(
      onTap: () {
        Get.toNamed('/work_room/${workRoom.id}');
      },
      child: Padding(
        padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Expanded(
                  child: Text(
                    workRoom.title,
                    style: Theme.of(context).textTheme.titleMedium,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
                Text(
                  _formatDate(workRoom.updatedAt),
                  style: TextStyle(color: Colors.grey[600], fontSize: 12),
                ),
              ],
            ),
            const SizedBox(height: 4),
            Text(
              workRoom.description,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 12),
            SizedBox(
              height: 40,
              child: ListView(
                scrollDirection: Axis.horizontal,
                children: workRoom.participants.map((participant) {
                  return Padding(
                    padding: const EdgeInsets.only(right: 8),
                    child: Chip(
                      avatar: CircleAvatar(
                        backgroundImage:
                            NetworkImage(participant.profilePictureUrl),
                      ),
                      label: Text(participant.username),
                    ),
                  );
                }).toList(),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// 날짜 포맷 YYYY-MM-DD HH:mm
  String _formatDate(DateTime dateTime) {
    return '${dateTime.year}-${dateTime.month.toString().padLeft(2, '0')}-${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
  }
}


// ===== FILE: ./lib/features/work_room/presentation/work_room_page.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/authentication/auth_controller.dart';
import 'package:legalfactfinder2025/features/chat/presentation/chat_screen.dart';
import 'package:legalfactfinder2025/features/confidentiality/presentation/signature_status_screen.dart';
import 'package:legalfactfinder2025/features/files/presentation/files_screen.dart';
import 'package:legalfactfinder2025/features/calendar/presentation/calendar_screen.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_model.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_repository.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/work_room_detail_screen.dart';
import 'package:legalfactfinder2025/features/chat/presentation/thread_list_screen.dart';
import 'package:legalfactfinder2025/features/audio_record/presentation/audio_recorder_page.dart';
import 'package:legalfactfinder2025/features/friend/presentation/friend_request_page.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/add_work_room_page.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/work_room_request_page.dart';

class WorkRoomPage extends StatefulWidget {
  const WorkRoomPage({Key? key}) : super(key: key);

  @override
  _WorkRoomPageState createState() => _WorkRoomPageState();
}

class _WorkRoomPageState extends State<WorkRoomPage> {
  late AuthController authController;
  late WorkRoomRepository workRoomRepository;
  String? workRoomId;
  String? userId;
  WorkRoom? workRoom;
  bool isLoading = true;
  String? errorMessage;

  @override
  void initState() {
    super.initState();

    authController = Get.find<AuthController>();
    workRoomRepository = WorkRoomRepository();

    userId = authController.getUserId();
    if (userId == null) {
      Future.delayed(Duration.zero, () => Get.offAllNamed('/login'));
      return;
    }

    workRoomId = Get.parameters['workRoomId'];
    if (workRoomId == null) {
      errorMessage = 'Invalid workRoomId: null';
      return;
    }

    _fetchWorkRoom();
  }

  Future<void> _fetchWorkRoom() async {
    try {
      final fetchedWorkRoom = await workRoomRepository.getWorkRoomById(workRoomId!);
      setState(() {
        workRoom = fetchedWorkRoom;
        isLoading = false;
      });
    } catch (e) {
      setState(() {
        errorMessage = e.toString();
        isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (userId == null || workRoomId == null) {
      return _buildError('Invalid user or work room ID.');
    }

    if (isLoading) {
      return _buildLoading();
    }

    if (errorMessage != null) {
      return _buildError(errorMessage!);
    }

    if (workRoom == null) {
      return _buildError('Work room not found.');
    }

    return _buildWorkRoomUI(context, workRoom!);
  }

  Widget _buildLoading() {
    return const Scaffold(
      body: Center(child: CircularProgressIndicator()),
    );
  }

  Widget _buildError(String message) {
    return Scaffold(
      body: Center(
        child: Text(
          message,
          style: const TextStyle(color: Colors.red, fontSize: 16),
        ),
      ),
    );
  }

  Widget _buildWorkRoomUI(BuildContext context, WorkRoom workRoom) {
    final participantsMap = {
      for (var participant in workRoom.participants)
        participant.userId: participant.username,
    };

    return DefaultTabController(
      length: 5,
      child: Scaffold(
        appBar: AppBar(
          title: Text(workRoom.title),
          actions: [
            /// **오른쪽 상단 플러스(+) 버튼 추가**
            IconButton(
              icon: const Icon(Icons.add),
              onPressed: () => _showBottomSheet(context),
            ),
          ],
          bottom: const TabBar(
            labelColor: Colors.lightBlue,
            unselectedLabelColor: Colors.grey,
            indicatorColor: Colors.transparent,
            tabs: [
              Tab(icon: Icon(Icons.chat, size: 20)),
              Tab(icon: Icon(Icons.attach_file, size: 20)),
              Tab(icon: Icon(Icons.calendar_today, size: 20)),
              Tab(icon: Icon(Icons.info, size: 20)),
              Tab(icon: Icon(Icons.lock, size: 20)),
            ],
          ),
        ),
        body: Stack(
          children: [
            TabBarView(
              children: [
                ChatScreen(workRoom: workRoom, myUserId: userId!),
                FilesScreen(workRoomId: workRoom.id),
                CalendarScreen(),
                WorkRoomDetailScreen(workRoom: workRoom),
                SignatureStatusScreen(workRoomId: workRoom.id),
              ],
            ),
            Positioned(
              top: 16,
              right: 16,
              child: GestureDetector(
                onTap: () {
                  showModalBottomSheet(
                    context: context,
                    isScrollControlled: true,
                    shape: const RoundedRectangleBorder(
                      borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
                    ),
                    builder: (context) => ThreadListScreen(
                      workRoomId: workRoom.id,
                      participantsMap: participantsMap,
                    ),
                  );
                },
                child: Container(
                  width: 40,
                  height: 40,
                  decoration: BoxDecoration(
                    shape: BoxShape.circle,
                    color: Colors.blue,
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withOpacity(0.2),
                        spreadRadius: 2,
                        blurRadius: 8,
                      ),
                    ],
                  ),
                  child: const Icon(Icons.view_list, color: Colors.white, size: 20),
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }

  /// **플러스(+) 버튼을 눌렀을 때 바텀시트 표시**
  void _showBottomSheet(BuildContext context) {
    print("Opening bottom sheet...");
    showModalBottomSheet(
      context: context,
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      builder: (context) {
        return Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            ListTile(
              leading: const Icon(Icons.person_add),
              title: const Text('친구 초대'),
              onTap: () {
                Navigator.pop(context);
                print("친구 초대 선택");
                Get.to(() => WorkRoomRequestPage(workRoomId: workRoomId!));
              },
            ),
            ListTile(
              leading: const Icon(Icons.note_add),
              title: const Text('회의록 생성'),
              onTap: () {
                Navigator.pop(context);
                print("Navigating to Audio Recorder page...");
                Get.to(() => AudioRecorderPage());
              },
            ),

          ],
        );
      },
    );
  }
}


// ===== FILE: ./lib/features/work_room/presentation/work_room_request_page.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/work_room/work_room_request_controller.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class WorkRoomRequestPage extends StatelessWidget {
  final WorkRoomRequestController controller = Get.put(WorkRoomRequestController());
  final TextEditingController emailController = TextEditingController();
  final String workRoomId;

  WorkRoomRequestPage({super.key, required this.workRoomId});

  @override
  Widget build(BuildContext context) {
    // ✅ 현재 로그인된 사용자 ID 가져오기
    final requesterId = Supabase.instance.client.auth.currentUser?.id;
    if (requesterId == null) {
      return const Center(child: Text("Please log in to send work room requests."));
    }

    return Scaffold(
      appBar: AppBar(title: const Text("Send Work Room Request")),
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              "Enter the email address of the user you want to invite to the work room.",
              style: TextStyle(fontSize: 16),
            ),
            const SizedBox(height: 10),
            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              decoration: const InputDecoration(
                labelText: "User Email",
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 20),

            Obx(() {
              return controller.isLoading.value
                  ? const Center(child: CircularProgressIndicator())
                  : SizedBox(
                width: double.infinity,
                child: ElevatedButton(
                  onPressed: () {
                    final recipientEmail = emailController.text.trim();
                    if (recipientEmail.isEmpty) {
                      Get.snackbar("Error", "Please enter an email address.");
                      return;
                    }
                    controller.sendWorkRoomRequest(requesterId, recipientEmail, workRoomId);
                  },
                  child: const Text("Send Request"),
                ),
              );
            }),

            const SizedBox(height: 20),

            // ✅ 성공 메시지 표시
            Obx(() {
              if (controller.successMessage.isNotEmpty) {
                return Text(
                  controller.successMessage.value,
                  style: const TextStyle(color: Colors.green, fontSize: 16),
                );
              }
              return const SizedBox.shrink();
            }),

            // ✅ 오류 메시지 표시
            Obx(() {
              if (controller.errorMessage.isNotEmpty) {
                return Text(
                  controller.errorMessage.value,
                  style: const TextStyle(color: Colors.red, fontSize: 16),
                );
              }
              return const SizedBox.shrink();
            }),
          ],
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/work_room/presentation/invitation_page.dart =====

import 'package:flutter/material.dart';

class InvitationPage extends StatelessWidget {
  const InvitationPage({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Invitation'),
      ),
      body: const Center(
        child: Text('Invitation Page'),
      ),
    );
  }
}


// ===== FILE: ./lib/features/work_room/presentation/work_room_requests_page.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/recieved_work_room_request_list_screen.dart';
import 'package:legalfactfinder2025/features/work_room/presentation/sent_work_room_request_list_screen.dart';


class WorkRoomRequestsPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 2,
      child: Scaffold(
        appBar: AppBar(
          title: Text("Work Room Invitations"),
          bottom: TabBar(
            tabs: [
              Tab(icon: Icon(Icons.inbox), text: "Received"),
              Tab(icon: Icon(Icons.send), text: "Sent"),
            ],
          ),
        ),
        body: TabBarView(
          children: [
            RecievedWorkRoomRequestListScreen(),
            SentWorkRoomRequestListScreen(),
          ],
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/work_room/presentation/sent_work_room_request_list_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/work_room/work_room_request_controller.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class SentWorkRoomRequestListScreen extends StatefulWidget {
  @override
  _SentWorkRoomRequestListScreenState createState() => _SentWorkRoomRequestListScreenState();
}

class _SentWorkRoomRequestListScreenState extends State<SentWorkRoomRequestListScreen> {
  final WorkRoomRequestController controller = Get.put(WorkRoomRequestController());

  @override
  void initState() {
    super.initState();

    // Ensure the API call happens after the widget is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final userId = Supabase.instance.client.auth.currentUser?.id;
      if (userId != null) {
        controller.fetchSentRequests(userId);
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      if (controller.isLoading.value) {
        return const Center(child: CircularProgressIndicator());
      }
      if (controller.errorMessage.isNotEmpty) {
        return Center(child: Text(controller.errorMessage.value));
      }
      if (controller.sentRequests.isEmpty) {
        return _buildEmptyState();
      }
      return ListView.builder(
        itemCount: controller.sentRequests.length,
        itemBuilder: (context, index) {
          final request = controller.sentRequests[index];
          return ListTile(
            leading: const Icon(Icons.send, color: Colors.blue),
            title: Text("Work Room ID: ${request['work_room_id']}"),
            subtitle: Text("Sent to: ${request['recipient_id'] ?? request['recipient_email']}"),
            trailing: _buildRequestActions(request['id']),
          );
        },
      );
    });
  }

  // ✅ 요청 취소 버튼
  Widget _buildRequestActions(String requestId) {
    return IconButton(
      icon: const Icon(Icons.cancel, color: Colors.red),
      onPressed: () {
        print("❌ Canceled request: $requestId");
        // TODO: 초대 취소 처리 로직 추가
      },
    );
  }

  // ✅ 보낸 초대가 없을 때의 UI
  Widget _buildEmptyState() {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.outgoing_mail, size: 80, color: Colors.grey),
          SizedBox(height: 16),
          Text(
            "No sent work room invitations",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          SizedBox(height: 10),
          Text(
            "You haven't sent any work room invitations yet.",
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 14, color: Colors.grey),
          ),
        ],
      ),
    );
  }
}


// ===== FILE: ./lib/features/work_room/presentation/work_room_detail_screen.dart =====

import 'package:flutter/material.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_model.dart';

class WorkRoomDetailScreen extends StatelessWidget {
  final WorkRoom workRoom;

  const WorkRoomDetailScreen({Key? key, required this.workRoom}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // WorkRoom title
            Text(
              workRoom.title,
              style: Theme.of(context).textTheme.headlineMedium,
            ),
            const SizedBox(height: 8),
            // WorkRoom description
            Text(
              workRoom.description,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            const SizedBox(height: 16),
            // Participants section
            const Text(
              "Participants",
              style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 8),
            ListView.separated(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: workRoom.participants.length,
              separatorBuilder: (context, index) => const Divider(),
              itemBuilder: (context, index) {
                final participant = workRoom.participants[index];
                return ParticipantTile(participant: participant);
              },
            ),
          ],
        ),
      ),
    );
  }
}

class ParticipantTile extends StatelessWidget {
  final Participant participant;

  const ParticipantTile({Key? key, required this.participant}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        // Profile picture
        CircleAvatar(
          radius: 24,
          backgroundImage: NetworkImage(participant.profilePictureUrl),
          backgroundColor: Colors.grey[300],
        ),
        const SizedBox(width: 12),
        // Participant details
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                participant.username,
                style: const TextStyle(fontSize: 14, fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 4),
              Text(
                participant.isLawyer ? "Lawyer" : "Participant",
                style: const TextStyle(fontSize: 12, color: Colors.grey),
              ),
            ],
          ),
        ),
        // Admin Badge
        if (participant.isAdmin)
          const Text(
            "Admin",
            style: TextStyle(
              fontSize: 12,
              fontWeight: FontWeight.bold,
              color: Colors.blue,
            ),
          ),
      ],
    );
  }
}


// ===== FILE: ./lib/features/work_room/presentation/recieved_work_room_request_list_screen.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/work_room/work_room_request_controller.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class RecievedWorkRoomRequestListScreen extends StatefulWidget {
  @override
  _RecievedWorkRoomRequestListScreenState createState() => _RecievedWorkRoomRequestListScreenState();
}

class _RecievedWorkRoomRequestListScreenState extends State<RecievedWorkRoomRequestListScreen> {
  final WorkRoomRequestController controller = Get.put(WorkRoomRequestController());

  @override
  void initState() {
    super.initState();


    // Ensure the API call happens after the widget is built
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final userId = Supabase.instance.client.auth.currentUser?.id;
      if (userId != null) {
        controller.fetchReceivedRequests(userId);

      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      if (controller.isLoading.value) {
        return const Center(child: CircularProgressIndicator());
      }
      if (controller.errorMessage.isNotEmpty) {
        return Center(child: Text(controller.errorMessage.value));
      }
      if (controller.receivedRequests.isEmpty) {
        return _buildEmptyState();
      }
      return ListView.builder(
        itemCount: controller.receivedRequests.length,
        itemBuilder: (context, index) {
          final request = controller.receivedRequests[index];
          return ListTile(
            leading: const Icon(Icons.meeting_room, color: Colors.blue),
            title: Text("Work Room ID: ${request['work_room_id']}"),
            subtitle: Text("Invited by: ${request['requester_id']}"),
            trailing: _buildRequestActions(request['id']),
          );
        },
      );
    });
  }

  // ✅ 초대장 수락/거절 버튼
  Widget _buildRequestActions(String requestId) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        IconButton(
          icon: const Icon(Icons.check, color: Colors.green),
          onPressed: () {
            print("✅ Accepted request: $requestId");
            // TODO: 초대 수락 처리 로직 추가
          },
        ),
        IconButton(
          icon: const Icon(Icons.close, color: Colors.red),
          onPressed: () {
            print("❌ Declined request: $requestId");
            // TODO: 초대 거절 처리 로직 추가
          },
        ),
      ],
    );
  }

  // ✅ 받은 초대가 없을 때의 UI
  Widget _buildEmptyState() {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(Icons.mail_outline, size: 80, color: Colors.grey),
          SizedBox(height: 16),
          Text(
            "No work room invitations",
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          SizedBox(height: 10),
          Text(
            "You haven't received any work room invitations yet.",
            textAlign: TextAlign.center,
            style: TextStyle(fontSize: 14, color: Colors.grey),
          ),
        ],
      ),
    );
  }
}


// ===== FILE: ./lib/features/work_room/work_room_controller.dart =====

import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_model.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_repository.dart';

class WorkRoomController extends GetxController {
  final WorkRoomRepository _repository;

  // 상태 변수
  var workRoom = Rxn<WorkRoom>(); // Rxn: null을 허용하는 반응형 변수
  var isLoading = false.obs; // 로딩 상태
  var errorMessage = ''.obs; // 에러 메시지
  var successMessage = ''.obs; // 성공 메시지

  WorkRoomController(this._repository);

  // WorkRoom 데이터 가져오기
  Future<void> fetchWorkRoom(String workRoomId) async {
    isLoading.value = true;
    errorMessage.value = '';
    try {
      final result = await _repository.getWorkRoomById(workRoomId);
      workRoom.value = result;
    } catch (e) {
      errorMessage.value = 'Failed to load WorkRoom: $e';
    } finally {
      isLoading.value = false;
    }
  }


  // 새로운 WorkRoom 추가
  Future<void> addWorkRoom(String title, String description, String userId) async {
    isLoading.value = true;
    errorMessage.value = '';
    successMessage.value = '';
    try {
      await _repository.createWorkRoom(title, description, userId);
      successMessage.value = 'WorkRoom added successfully!';
    } catch (e) {
      errorMessage.value = 'Failed to add WorkRoom: $e';
    } finally {
      isLoading.value = false;
    }
  }
}


// ===== FILE: ./lib/features/authentication/auth_controller.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/features/authentication/data/auth_repository.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class AuthController extends GetxController {
  final AuthRepository authRepository;

  AuthController(this.authRepository) {
    print("🟢 AuthController initialized");
  }

  var isLoading = false.obs;
  var currentUser = Rxn<User>();  // Rxn to hold current user

  // Reactive userId that listens to changes in currentUser
  Rx<String?> userId = Rx<String?>(null);

  @override
  void onInit() {
    super.onInit();
    print("🔄 onInit called in AuthController");

    currentUser.value = authRepository.getCurrentUser();
    print("🟢 Current User onInit: ${currentUser.value?.email ?? 'No user logged in'}");

    // Update userId reactively based on currentUser
    if (currentUser.value != null) {
      userId.value = currentUser.value!.id;
    }

    // Listen for auth state changes (e.g., login, logout)
    Supabase.instance.client.auth.onAuthStateChange.listen((data) async {
      await refreshUser();
      print("🔄 Auth state changed: ${currentUser.value?.email ?? 'User logged out'}");

      // Update userId based on currentUser after auth state change
      if (currentUser.value != null) {
        userId.value = currentUser.value!.id;
      } else {
        userId.value = null;  // Clear userId on logout
      }

      if (currentUser.value == null) {
        print("🔴 User logged out. Redirecting to /login");
        _navigateToLogin();
      } else if (!isEmailConfirmed()) {
        print("⚠️ Email is not confirmed. Redirecting to /verify-email.");
        Get.offAllNamed('/verify-email');
      }
    });
  }
// ✅ 이메일 인증 이메일 재발송
  Future<void> resendVerificationEmail(String email) async {
    try {
      print("🔄 Resending verification email to: $email");

      // ✅ Supabase에서 이메일 인증 이메일을 다시 보내려면 `signUp`을 다시 호출
      await Supabase.instance.client.auth.signUp(email: email, password: "dummy_password");

      print("✅ Verification email resent successfully");
    } catch (e) {
      print("❌ Failed to resend verification email: $e");
    }
  }

  // ✅ 이메일 인증 상태 확인
  bool isEmailConfirmed() {
    final user = currentUser.value;
    return user != null && user.emailConfirmedAt != null;
  }

  // ✅ 사용자 정보 새로고침
  Future<void> refreshUser() async {
    try {
      final newUser = await Supabase.instance.client.auth.getUser();
      if (newUser.user != null) {
        currentUser.value = newUser.user;
        print("🔄 User refreshed: ${currentUser.value?.email}, Email Confirmed: ${currentUser.value?.emailConfirmedAt != null}");
      }
    } catch (e) {
      print("❌ Error refreshing user: $e");
    }
  }

  // ✅ 네비게이션 실행 (로그인 페이지로 이동)
  void _navigateToLogin() {
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (Get.context != null) {
        Get.offAllNamed('/login');
      } else {
        print("⚠️ Still no Get.context available. Retrying in 100ms...");
        Future.delayed(const Duration(milliseconds: 100), () {
          if (Get.context != null) {
            Get.offAllNamed('/login');
          } else {
            print("❌ Navigation failed: Get.context is still null!");
          }
        });
      }
    });
  }

  // ✅ 이메일 로그인
  Future<void> signInWithEmail(String email, String password) async {
    try {
      print("🔄 Attempting to sign in with email: $email");
      isLoading(true);
      await authRepository.signInWithEmail(email, password);
      await refreshUser();

      if (currentUser.value != null) {
        if (!isEmailConfirmed()) {
          print("⚠️ Email is not confirmed. Redirecting to /verify-email.");
          Get.offAllNamed('/verify-email');
        } else {
          print("✅ Login successful: ${currentUser.value!.email}");
          Get.offAllNamed('/main');
        }
      } else {
        print("❌ Login failed: No user returned from Supabase");
        Get.snackbar("Login Failed", "No user information received.");
      }
    } catch (e) {
      print("❌ Login error: $e");
      Get.snackbar("Login Failed", e.toString(), backgroundColor: Colors.red.withOpacity(0.8), colorText: Colors.white);
    } finally {
      isLoading(false);
    }
  }

  // ✅ 이메일 회원가입 (회원가입 후 "이메일 확인" 페이지로 이동)
  // ✅ 이메일 회원가입 (회원가입 후 "이메일 확인" 페이지로 이동)
  // ✅ 이메일 회원가입 (회원가입 후 "이메일 확인" 페이지로 이동)
  Future<void> signUpWithEmail(String email, String password, String username, String firstName, String lastName) async {
    try {
      print("🔄 Signing up with email: $email, username: $username, firstName: $firstName, lastName: $lastName");
      isLoading(true);
      await authRepository.signUpWithEmail(email, password, username, firstName, lastName);
      print("✅ Registration successful. Redirecting to verify-email page.");

      Get.snackbar(
        "Success",
        "A verification email has been sent to your inbox. Please verify your email before logging in.",
        backgroundColor: Colors.green.withOpacity(0.8),
        colorText: Colors.white,
      );

      // ✅ 회원가입 후 이메일 인증 안내 페이지로 이동
      Get.offAllNamed('/verify-email');
    } catch (e) {
      print("❌ Registration error: $e");
      Get.snackbar("Registration Failed", e.toString(), backgroundColor: Colors.red.withOpacity(0.8), colorText: Colors.white);
    } finally {
      isLoading(false);
    }
  }



  // ✅ 비밀번호 재설정 요청
  Future<void> resetPassword(String email) async {
    try {
      print("🔄 Requesting password reset for: $email");
      isLoading(true);
      await authRepository.resetPassword(email);
      print("✅ Password reset email sent to: $email");

      Get.snackbar("Success", "Password reset email sent.", backgroundColor: Colors.green.withOpacity(0.8), colorText: Colors.white);
    } catch (e) {
      print("❌ Password reset error: $e");
      Get.snackbar("Error", e.toString(), backgroundColor: Colors.red.withOpacity(0.8), colorText: Colors.white);
    } finally {
      isLoading(false);
    }
  }

  // ✅ 로그아웃
  Future<void> signOut() async {
    print("🔄 Signing out user: ${currentUser.value?.email ?? 'Unknown user'}");
    await authRepository.signOut();
    currentUser.value = null;
    userId.value = null;  // Clear the reactive userId on sign out
    print("🔴 User signed out. Redirecting to /login");
    Get.offAllNamed('/login');
  }

  // ✅ 현재 로그인한 사용자의 ID 반환
  String? getUserId() {
    print("🔄 Fetching user ID: ${currentUser.value?.id ?? 'No user'}");
    return currentUser.value?.id;
  }

  // ✅ 회원 탈퇴 (계정 삭제)
  Future<void> deleteAccount() async {
    try {
      print("🔄 Withdrawing membership for user: ${currentUser.value?.email ?? 'Unknown user'}");
      await Supabase.instance.client.auth.admin.deleteUser(currentUser.value!.id);
      print("✅ Membership withdrawn successfully");
      Get.snackbar("Success", "Your membership has been withdrawn. All data has been deleted.");
      currentUser.value = null;
      Get.offAllNamed('/login');
    } catch (e) {
      print("❌ Membership withdrawal failed: $e");
      Get.snackbar("Error", "Failed to withdraw membership. Try again.");
    }
  }

}


// ===== FILE: ./lib/features/authentication/data/auth_user.dart =====

class LoggedInUser {
  final String id;
  final String username;
  final String email;
  final String? profilePictureUrl;
  final bool isLawyer;

  LoggedInUser({
    required this.id,
    required this.username,
    required this.email,
    this.profilePictureUrl,
    required this.isLawyer,
  });

  factory LoggedInUser.fromJson(Map<String, dynamic> json) {
    return LoggedInUser(
      id: json['id'],
      username: json['username'],
      email: json['email'],
      profilePictureUrl: json['profile_picture_url'],
      isLawyer: json['is_lawyer'] ?? false,
    );
  }
}

// ===== FILE: ./lib/features/authentication/data/auth_repository.dart =====

import 'package:supabase_flutter/supabase_flutter.dart';

class AuthRepository {
  final SupabaseClient supabase;

  AuthRepository(this.supabase);

  // 이메일 로그인
  Future<void> signInWithEmail(String email, String password) async {
    await supabase.auth.signInWithPassword(email: email, password: password);
  }

   // ✅ 이메일 회원가입 (provider 추가)
  Future<void> signUpWithEmail(String email, String password, String username, String firstName, String lastName) async {
    await supabase.auth.signUp(
      email: email,
      password: password,
      data: {
        'username': username,
        'first_name': firstName,
        'last_name': lastName,
        'provider': 'email',  // ✅ provider 값을 명시적으로 추가
      },
    );
  }
  // 비밀번호 재설정 이메일 전송
  Future<void> resetPassword(String email) async {
    await supabase.auth.resetPasswordForEmail(email);
  }

  // 현재 로그인된 사용자 가져오기
  User? getCurrentUser() {
    return supabase.auth.currentUser;
  }

  // 로그아웃
  Future<void> signOut() async {
    await supabase.auth.signOut();
  }
}

// ===== FILE: ./lib/features/authentication/data/auth_model.dart =====

class AuthModel {
  final String email;
  final String password;

  AuthModel({required this.email, required this.password});
}

// ===== FILE: ./lib/features/authentication/presentation/register_page.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/app/app_theme.dart';
import 'package:legalfactfinder2025/constants.dart';
import 'package:legalfactfinder2025/features/agreement/presentation/privacy_polity_page.dart';
import 'package:legalfactfinder2025/features/agreement/presentation/term_of_service_page.dart';
import '../auth_controller.dart';

class RegisterPage extends StatelessWidget {
  final AuthController authController = Get.find();
  final TextEditingController emailController = TextEditingController();
  final TextEditingController passwordController = TextEditingController();
  final TextEditingController usernameController = TextEditingController(); // ✅ 추가
  final TextEditingController firstNameController = TextEditingController();
  final TextEditingController lastNameController = TextEditingController();

  // ✅ 체크박스 상태 관리
  final RxBool agreeToTerms = false.obs;
  final RxBool agreeToPrivacy = false.obs;
  final RxBool agreeToMarketing = false.obs;

  RegisterPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SingleChildScrollView( // ✅ 스크롤 가능하도록 변경
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 20.0, vertical: 40.0), // ✅ 위아래 패딩 유지
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const SizedBox(height: 40),
              Center(
                child: Column(
                  children: [
                    Text(appTitle, style: Theme.of(context).textTheme.titleLarge),
                    const SizedBox(height: 8),
                    Text(appSubtitle, style: Theme.of(context).textTheme.titleMedium, textAlign: TextAlign.center),
                  ],
                ),
              ),
              const SizedBox(height: 40),

              TextField(
                controller: usernameController, // ✅ username 입력 필드 추가
                decoration: const InputDecoration(labelText: "Username"),
              ),
              const SizedBox(height: 15),
              TextField(
                controller: emailController,
                keyboardType: TextInputType.emailAddress,
                decoration: const InputDecoration(labelText: "Email"),
              ),
              const SizedBox(height: 15),

              TextField(
                controller: passwordController,
                obscureText: true,
                decoration: const InputDecoration(labelText: "Password"),
              ),
              const SizedBox(height: 25),

              Divider(),

              const SizedBox(height: 25),



              TextField(
                controller: firstNameController, // ✅ first_name 입력 필드 추가
                decoration: const InputDecoration(labelText: "First Name"),
              ),
              const SizedBox(height: 15),

              TextField(
                controller: lastNameController, // ✅ last_name 입력 필드 추가
                decoration: const InputDecoration(labelText: "Last Name"),
              ),
              const SizedBox(height: 25),

              Divider(),

              const SizedBox(height: 25),

              // ✅ 약관 동의 체크박스 (패딩 축소)
              Obx(() => CheckboxListTile(
                value: agreeToTerms.value,
                onChanged: (value) => agreeToTerms.value = value!,
                title: Wrap(
                  crossAxisAlignment: WrapCrossAlignment.center,
                  spacing: 2, // ✅ 요소 간 여백 최소화
                  children: [
                    const Text("I agree to the "),
                    GestureDetector(
                      onTap: () => Get.to(() => TermsOfServicePage()),
                      child: const Text("Terms of Service", style: AppTheme.interactiveTextStyle),
                    ),
                  ],
                ),
                controlAffinity: ListTileControlAffinity.leading,
                contentPadding: const EdgeInsets.symmetric(horizontal: 10.0), // ✅ 좌우 패딩 절반 축소
              )),

              Obx(() => CheckboxListTile(
                value: agreeToPrivacy.value,
                onChanged: (value) => agreeToPrivacy.value = value!,
                title: Wrap(
                  crossAxisAlignment: WrapCrossAlignment.center,
                  spacing: 2, // ✅ 요소 간 여백 최소화
                  children: [
                    const Text("I agree to the "),
                    GestureDetector(
                      onTap: () => Get.to(() => PrivacyPolicyPage()),
                      child: const Text("Privacy Policy", style: AppTheme.interactiveTextStyle),
                    ),
                  ],
                ),
                controlAffinity: ListTileControlAffinity.leading,
                contentPadding: const EdgeInsets.symmetric(horizontal: 10.0), // ✅ 좌우 패딩 절반 축소
              )),

              Obx(() => CheckboxListTile(
                value: agreeToMarketing.value,
                onChanged: (value) => agreeToMarketing.value = value!,
                title: const Text("I agree to receive marketing emails and promotions (optional)"),
                controlAffinity: ListTileControlAffinity.leading,
                contentPadding: const EdgeInsets.symmetric(horizontal: 10.0), // ✅ 좌우 패딩 절반 축소
              )),

              const SizedBox(height: 10),

              // ✅ 회원가입 버튼 (필수 동의 항목 확인)
              Obx(() {
                final isButtonEnabled = agreeToTerms.value && agreeToPrivacy.value;

                return authController.isLoading.value
                    ? const Center(child: CircularProgressIndicator())
                    : SizedBox(
                  width: double.infinity, // ✅ 버튼 너비 확장
                  child: ElevatedButton(
                    onPressed: isButtonEnabled ? () {
                      final email = emailController.text.trim();
                      final password = passwordController.text.trim();
                      final username = usernameController.text.trim();
                      final lastName = lastNameController.text.trim();
                      final firstName = firstNameController.text.trim();

                      if (email.isEmpty || password.isEmpty||username.isEmpty) {
                        Get.snackbar("Error", "Username, email and password cannot be empty");
                        return;
                      }

                      authController.signUpWithEmail(email, password,username, firstName, lastName);
                    } : null,
                    child: const Text("Sign Up"),
                  ),
                );
              }),

              const SizedBox(height: 10),

              Center(
                child: TextButton(
                  onPressed: () => Get.offNamed('/login'),
                  child: const Text("Already have an account? Log in", style: AppTheme.interactiveTextStyle),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/authentication/presentation/verify_email_page.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/app/app_theme.dart';
import '../auth_controller.dart';

class VerifyEmailPage extends StatelessWidget {
  final AuthController authController = Get.find();

  VerifyEmailPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 80),
            Text("Verify Your Email", style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 8),
            Text(
              "We have sent a verification email to your inbox. Please click the link in the email to complete the verification process.",
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 40),

            // ✅ 이메일 인증 상태 확인 버튼
            // Center(
            //   child: SizedBox(
            //     width: double.infinity,
            //     child: ElevatedButton(
            //
            //       onPressed: () async {
            //         await authController.refreshUser();
            //         if (authController.isEmailConfirmed()) {
            //           print("✅ Email verified! Redirecting to main...");
            //           Get.offAllNamed('/main');
            //         } else {
            //           print("❌ Email not verified yet.");
            //           Get.snackbar("Error", "Your email is still not verified. Please check your inbox.");
            //         }
            //       },
            //       child: const Text("Check Verification Status"),
            //     ),
            //   ),
            // ),

            const SizedBox(height: 20),

            // ✅ 다시 로그인 버튼
            Center(
              child: TextButton(
                onPressed: () {
                  authController.signOut();
                  Get.offAllNamed('/login');
                },
                child: const Text("Back to Login", style: AppTheme.interactiveTextStyle),
              ),
            ),
          ],
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/authentication/presentation/reset_password_page.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/app/app_theme.dart';
import 'package:legalfactfinder2025/constants.dart';
import '../auth_controller.dart';

class ResetPasswordPage extends StatelessWidget {
  final AuthController authController = Get.find();
  final TextEditingController emailController = TextEditingController();

  ResetPasswordPage({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            const SizedBox(height: 80),
            Text(appTitle, style: Theme.of(context).textTheme.titleLarge),
            const SizedBox(height: 8),
            Text(appSubtitle, style: Theme.of(context).textTheme.titleMedium),
            const SizedBox(height: 40),
            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              decoration: const InputDecoration(labelText: "Email"),
            ),
            const SizedBox(height: 25),
            Obx(() {
              return authController.isLoading.value
                  ? const Center(child: CircularProgressIndicator())
                  : ElevatedButton(
                onPressed: () {
                  authController.resetPassword(emailController.text);
                },
                child: const Center(child: Text("Send Reset Email")),
              );
            }),
            const SizedBox(height: 10),
            TextButton(
              onPressed: () => Get.offNamed('/login'),
              child: const Text("Back to Login", style: AppTheme.interactiveTextStyle),
            ),
          ],
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/features/authentication/presentation/login_page.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/app/app_theme.dart';
import 'package:legalfactfinder2025/constants.dart';
import '../auth_controller.dart';

class LoginPage extends StatelessWidget {
  final AuthController authController = Get.find();
  final TextEditingController emailController = TextEditingController();
  final TextEditingController passwordController = TextEditingController();

  LoginPage({super.key});

  @override
  Widget build(BuildContext context) {
    print("🟢 LoginPage loaded");

    return Scaffold(
      body: Padding(
        padding: const EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.center, // ✅ 전체 요소 가운데 정렬
          children: [
            const SizedBox(height: 80),

            // ✅ Legal FactFinder 제목과 슬로건 가운데 정렬
            Center(
              child: Column(
                children: [
                  Text(appTitle, style: Theme.of(context).textTheme.titleLarge, textAlign: TextAlign.center),
                  const SizedBox(height: 8),
                  Text(appSubtitle, style: Theme.of(context).textTheme.titleMedium, textAlign: TextAlign.center),
                ],
              ),
            ),
            const SizedBox(height: 40),

            TextField(
              controller: emailController,
              keyboardType: TextInputType.emailAddress,
              decoration: const InputDecoration(labelText: "Email"),
            ),
            const SizedBox(height: 15),

            TextField(
              controller: passwordController,
              obscureText: true,
              decoration: const InputDecoration(labelText: "Password"),
            ),
            const SizedBox(height: 25),

            Obx(() {
              return authController.isLoading.value
                  ? const Center(child: CircularProgressIndicator())
                  : SizedBox(
                width: double.infinity, // ✅ 버튼 너비 확장
                child: ElevatedButton(
                  onPressed: () async {
                    final email = emailController.text.trim();
                    final password = passwordController.text.trim();

                    if (email.isEmpty || password.isEmpty) {
                      _showAlertDialog(context, "Error", "Email and password cannot be empty.");
                      return;
                    }

                    authController.isLoading.value = true;
                    try {
                      await authController.signInWithEmail(email, password);

                      // ✅ 이메일 인증 여부 확인 후 미인증 시 다이얼로그 표시
                      if (!authController.isEmailConfirmed()) {
                        _showResendEmailDialog(context, email);
                      }
                    } catch (e) {
                      _showAlertDialog(context, "Login Failed", e.toString());
                    } finally {
                      authController.isLoading.value = false;
                    }
                  },
                  child: const Text("Login"),
                ),
              );
            }),
            const SizedBox(height: 10),

            TextButton(
              onPressed: () => Get.toNamed('/register'),
              child: const Text("Don't have an account? Sign up", style: AppTheme.interactiveTextStyle),
            ),
            TextButton(
              onPressed: () => Get.toNamed('/reset-password'),
              child: const Text("Forgot password?", style: AppTheme.interactiveTextStyle),
            ),
          ],
        ),
      ),
    );
  }

  // ✅ 일반 경고 다이얼로그
  void _showAlertDialog(BuildContext context, String title, String message) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: Text(title),
          content: Text(message),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("OK", style: AppTheme.interactiveTextStyle),
            ),
          ],
        );
      },
    );
  }

  // ✅ 이메일 미인증 시 인증 이메일 재발송 다이얼로그
  void _showResendEmailDialog(BuildContext context, String email) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text("Email Not Verified"),
          content: const Text("Your email has not been verified. Would you like to resend the verification email?"),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text("No", style: AppTheme.interactiveTextStyle),
            ),
            TextButton(
              onPressed: () async {
                Navigator.pop(context);
                await authController.resendVerificationEmail(email);
                _showAlertDialog(context, "Verification Email Sent", "A new verification email has been sent to your inbox.");
              },
              child: const Text("Yes", style: TextStyle(color: Colors.blue)),
            ),
          ],
        );
      },
    );
  }
}


// ===== FILE: ./lib/features/authentication/presentation/widgets/auth_form.dart =====



// ===== FILE: ./lib/main.dart =====

import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:legalfactfinder2025/app/app_routes.dart';
import 'package:legalfactfinder2025/app/app_theme.dart';
import 'package:legalfactfinder2025/app/main_layout.dart';
import 'package:legalfactfinder2025/constants.dart';
import 'package:legalfactfinder2025/features/authentication/auth_controller.dart';
import 'package:legalfactfinder2025/features/authentication/data/auth_repository.dart';
import 'package:legalfactfinder2025/features/chat/message_controller.dart';
import 'package:legalfactfinder2025/features/chat/data/message_repository.dart';
import 'package:legalfactfinder2025/features/chat/data/thread_repository.dart';
import 'package:legalfactfinder2025/features/chat/thread_controller.dart';
import 'package:legalfactfinder2025/features/chat/data/thread_message_repository.dart';
import 'package:legalfactfinder2025/features/chat/thread_message_controller.dart';
import 'package:legalfactfinder2025/features/document_annotation/annotation_controller.dart';
import 'package:legalfactfinder2025/features/document_annotation/data/annotation_repository.dart';
import 'package:legalfactfinder2025/features/files/data/file_repository.dart';
import 'package:legalfactfinder2025/features/files/file_view_controller.dart';
import 'package:legalfactfinder2025/features/notification/data/notification_repository.dart';
import 'package:legalfactfinder2025/features/notification/presentation/notification_list_controller.dart';
import 'package:legalfactfinder2025/features/work_room/data/work_room_repository.dart';
import 'package:legalfactfinder2025/features/work_room/work_room_controller.dart';
import 'package:legalfactfinder2025/features/work_room/work_room_list_controller.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

Future<void> initSupabase() async {
  await Supabase.initialize(
    url: baseUrl, // constants.dart에서 가져온 baseUrl
    anonKey: anonKey, // constants.dart에서 가져온 anonKey
  );
}
late String initialRoute;

void main() async {
  WidgetsFlutterBinding.ensureInitialized(); // Flutter framework 초기화
  await initSupabase(); // Supabase 초기화


  final authRepository = AuthRepository(Supabase.instance.client);
  final authController = AuthController(authRepository);
  Get.put(authController);


  final annotationController = AnnotationController();
  Get.put(annotationController);


  // NotificationRepository 및 Controller 초기화
  final notificationRepository = NotificationRepository(
    getUserNotificationsUrl: getUserNotificationsEdgeFunctionUrl,
    jwtToken: jwtToken,
  );
  Get.put(NotificationListController(notificationRepository: notificationRepository));

  // WorkRoomRepository 및 Controller 초기화
  final workRoomRepository = WorkRoomRepository();
  Get.put(WorkRoomController(workRoomRepository)); // WorkRoomController 등록

  // WorkRoomRepository 및 Controller 초기화
  Get.put(WorkRoomListController()); // WorkRoomController 등록

  // ChatRepository 및 Controller 초기화
  final messageRepository = MessageRepository(
    getChatMessagesEdgeFunctionUrl: getChatMessagesEdgeFunctionUrl,
    putChatMessageEdgeFunctionUrl: putChatMessageEdgeFunctionUrl,
    jwtToken: jwtToken,
  );
  Get.put(MessageController(messageRepository)); // Register ChatController

  // ThreadRepository 및 Controller 초기화
  final threadRepository = ThreadRepository(
    getThreadsEdgeFunctionUrl: getThreadsEdgeFunctionUrl,
    jwtToken: jwtToken,
  );
  Get.put(ThreadController(threadRepository)); // Register ThreadController

  // ThreadMessageRepository 및 Controller 초기화
  final threadMessageRepository = ThreadMessageRepository(
    getParentMessageEdgeFunctionUrl: getParentMessageEdgeFunctionUrl,
    getThreadMessagesEdgeFunctionUrl: getThreadChatMessagesEdgeFunctionUrl,
    putThreadMessageEdgeFunctionUrl: putThreadChatMessageEdgeFunctionUrl,
    jwtToken: jwtToken,
  );
  Get.put(ThreadMessageController(threadMessageRepository)); // Register ThreadMessageController

  // FileViewController 등록
  Get.put(FileViewController(FileRepository()));




  // ✅ 초기 경로 결정: 로그인 여부 & 이메일 인증 상태 확인
  if (authController.currentUser.value == null) {
    initialRoute = '/login'; // 로그인하지 않은 경우 로그인 페이지로 이동
  } else if (!authController.isEmailConfirmed()) {
    initialRoute = '/verify-email'; // 로그인했지만 이메일 인증이 안 된 경우
  } else {
    initialRoute = '/main'; // 로그인 & 이메일 인증 완료된 경우
  }
  runApp(MyApp());

  // 로그인 상태 확인 후 초기 화면 설정
  Future.delayed(Duration.zero, () {
    if (authController.currentUser.value != null) {
      Get.offAllNamed('/main');
    } else {
      Get.offAllNamed('/login');
    }
  });
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Legal FactFinder',
      theme: AppTheme.themeData,
      // home: MainLayout(), // BottomNavigationBar를 포함한 메인 화면
      initialRoute: initialRoute, // 로그인 화면을 기본 화면으로 설정
      getPages: AppRoutes.routes, // AppRoutes의 라우트 리스트 연결
      unknownRoute: GetPage(
        name: '/not_found',
        page: () => Scaffold(
          body: Center(
            child: Text('Page not found'),
          ),
        ),
      ),
    );
  }
}


// ===== FILE: ./lib/constants.dart =====

// lib/constants/constants.dart

// Supabase 설정
const String baseUrl = 'https://jschbqhrzkdqcpbidqhj.supabase.co';
const String anonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImpzY2hicWhyemtkcWNwYmlkcWhqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzc0NDM3MjMsImV4cCI6MjA1MzAxOTcyM30.0LZdDrL_MvVUOdHQm8quR1xfpWIyxq7MofdaJ_hNRJQ';

// Supabase Edge Functions
const String getChatMessagesEdgeFunctionUrl = '$baseUrl/functions/v1/get_chat_messages';
const String putChatMessageEdgeFunctionUrl = '$baseUrl/functions/v1/put_chat_message';
const String getThreadChatMessagesEdgeFunctionUrl = '$baseUrl/functions/v1/get_thread_chat_messages';
const String putThreadChatMessageEdgeFunctionUrl = '$baseUrl/functions/v1/put_thread_chat_message';
const String getThreadsEdgeFunctionUrl = '$baseUrl/functions/v1/get_threads_by_work_room_id';
const String getParentMessageEdgeFunctionUrl = '$baseUrl/functions/v1/get_chat_message_by_id';
const String getUserNotificationsEdgeFunctionUrl = '$baseUrl/functions/v1/get_user_notifications';
const String putDocumentAnnotationEdgeFunctionUrl = '$baseUrl/functions/v1/put_document_annotation';


// JWT Token
const String jwtToken = anonKey; // 재사용 가능하도록 alias 설정

// for test
const String TEST_USER_NAME = "TEST USER";
const String TEST_USER_EMAIL = "iamjaehaklee@gmail.com";

const String appTitle = "Legal FactFinder";
const String appSubtitle = "철저한 팩트 파악은 법률 문제 해결의 핵심입니다!";
